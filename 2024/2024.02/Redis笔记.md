# Redis概述

[Redis介绍、安装以及数据结构(操作命令) - 掘金 (juejin.cn)](https://juejin.cn/post/6844903910579109896)

使用C语言开发的高性能**键值对k-v内存数据库，可以用作数据库，缓存和消息中间件**。它是一种**NoSQL非关系型数据库**。

- 内存数据库，读写快。支持并发10W QPS。
- ❗️❗️❗️单进程单线程，线程安全，采用IO多路复用。
- 丰富的数据结构。
- 支持数据持久化，将内存中数据保存在磁盘中，重启时加载。
- 主从复制。

# Redis的应用场景

- **内存数据库**（登录信息、购物车信息、用户浏览记录等）
- **缓存服务器**（商品数据、广告数据等等）（**最多使用**）
- 解决分布式集群架构中的 session 分离问题（ session 共享）
- 任务队列（秒杀、抢购、12306等等）
- 分布式锁的实现
- 支持发布订阅的消息模式
- 应用排行榜(有序集合)
- 网站访问统计
- 数据过期处理（可以精确到毫秒）

# Redis的数据结构以及操作命令

## 字符串String

### 命令

```shell
# 赋值
SET key value [EX seconds] [PX milliseconds] [NX|XX]

# 取值 
GET key

# 设置新值，返回旧值
GETSET key value

EX seconds：键过期时间
PX milliseconds：为键设置毫秒级过期时间
NX：键必须不存在才可以设置成功，用于添加
XX：键必须存在，才可以设置成功，用于更新

#当value值为整数时，才可以使用数值增减命令，incr/decr为增加/减少1，incrby/decrby为增加/减少具体的数值，数值的增减是原子操作。
127.0.0.1:6379> set counter 100
OK
127.0.0.1:6379> incr counter
(integer) 101
127.0.0.1:6379> incrby counter 20
(integer) 121
127.0.0.1:6379> decr counter
(integer) 120
127.0.0.1:6379> decrby counter 10
(integer) 110

#mset/mget 同时设置/获取多个键值 在单个命令中设置/获取多个键值是可以减少延迟的
127.0.0.1:6379> mset k1 10 k2 20 k3 30
OK
127.0.0.1:6379> mget k1 k2 k3
1) "10"
2) "20"
3) "30"
```

### 使用场景

- 黑名单IP的计数器

- 常规的key-value缓存
- 计数：微博数、粉丝数等
- 应用INCR原子计数生产全局唯一id或单号

## 散列Hash

### 命令

```shell
# 设置一个字段值
HSET key field value 
# 设置多个字段值
HMSET key field value [field value ...]
# 字段不存在时赋值
HMSETNX key field value
# 获取一个字段值
HGET key field 
# 获取多个字段值
HMGET key field [field ...] 
# 获取所有字段值
HGETALL key

127.0.0.1:6379> hmset user name zou age 23
OK
127.0.0.1:6379> hset user location Guangzhou
(integer) 1
127.0.0.1:6379> hget user name
"zou"
127.0.0.1:6379> hgetall user
1) "name"
2) "zou"
3) "age"
4) "23"
5) "location"
6) "Guangzhou"

127.0.0.1:6379> hincrby user age 1
(integer) 24


# 判断字段是否存在
HEXISTS key field
# 只获取字段名
HKEYS key
# 只获取字段值
HVALS key
# 获取字段数量
HLEN key
# 获取所有字段和值
HGETALL key
```

### String和Hash的区别

Hash类型适合存储那些对象数据，特别是对象属性经常发生【增删改】操作的数据。 String类型也可以存储对象数据，将Java对象转成json字符串或序列化进行存储，这种存储适合【查询】操作。

### 使用场景

- 存储结构化数据对象，如用户信息、商品信息。


## 列表List

Redis的列表是链表结构的，可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1) ，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。

### 命令

```shell
# 列表的左端添加元素
LPUSH key value [value ...]
# 列表的右端添加元素
RPUSH key value [value ...]
127.0.0.1:6379> lpush list:1 1 2 3 
(integer) 3 
127.0.0.1:6379> rpush list:1 4 5 6 
(integer) 3 

#lrange 获取列表片段
#获取列表中的某一片段，返回start、stop之间的所有元素（包含两端的元素），索引从0开始，索引可以是负数，表明从结尾开始计数：所以-1是最后一个元素，-2是列表的倒数第二个元素
127.0.0.1:6379> lrange  list:1 0 2 
1) "2" 
2) "1" 
3) "4"

#lpop/rpop 从列表两端弹出元素
#从列表两端弹出一个元素，会分两步完成：
#第一步是将列表左边的元素从列表中移除
#第二步是返回被移除的元素值
LPOP key
RPOP key
127.0.0.1:6379>lpop list:1 
"3“ 
127.0.0.1:6379>rpop list:1 
"6“

# 获取列表中元素的个数
LLEN key
# 删除列表中指定个数的值
# - 当count>0时， LREM会从列表左边开始删除。
# - 当count<0时， LREM会从列表后边开始删除。
# - 当count=0时， LREM删除所有值为value的元素
LREM key count value
# 获取指定索引的元素值
LINDEX key index
# 只保留列表指定片段,指定范围和lrange一致
LTRIM key start stop
# 向列表中插入元素
LINSERT key BEFORE|AFTER pivot value
# 将元素从一个列表转移到另一个列表中
RPOPLPUSH source destination
```

### 使用场景

- 各种列表：关注列表、粉丝列表、评论
- 消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出执行
- 利用LRANGE可以很方便的实现list内容分页的功能
- 取最新N个数据的操作

## 集合Set

Set是字符串的无序集合，其中的数据是**不重复**且**没有顺序**，集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为 0(1)，Redis 还提供了多个集合之间的交集、并集、差集的运算。

### 命令

```shell
#sadd/srem 添加/删除元素
SADD key member [member ...]
SREM key member [member ...]

127.0.0.1:6379> sadd set a b c 
(integer) 3 
127.0.0.1:6379> sadd set a 
(integer) 0 
127.0.0.1:6379> srem set c d 
(integer) 1 

#smembers 获取所有元素
SMEMBERS key 

# 判断元素是否在集合中, 返回1为在，0为不在
SISMEMBER key member

#SDIFF - 集合的差集运算 A-B：属于A并且不属于B的元素构成的集合
127.0.0.1:6379> sadd setA 1 2 3
(integer) 3
127.0.0.1:6379> sadd setB 2 3 4
(integer) 3
127.0.0.1:6379> sdiff setA setB
1) "1"
127.0.0.1:6379> sdiff setB setA
1) "4"

#SINTER - 集合的交集运算 A ∩ B：属于A且属于B的元素构成的集合
127.0.0.1:6379> sinter setA setB
1) "2"
2) "3"

#SUNION - 集合的并集运算 A ∪ B：属于A或者属于B的元素构成的集合
127.0.0.1:6379> sunion setA setB
1) "1"
2) "2"
3) "3"
4) "4"

# 获得集合中元素的个数
SCARD key
# 从集合中随机弹出一个元素
SPOP key
```

### 使用场景

- 需要去重的列表。
- 提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能。

## 有序集合ZSET

有序集合（Sorted Set，zset）在Set集合类型的基础上，有序集合类型为集合中的每个元素都关联一个分数(score) ，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。

### 实现

有序集合类型 (SortedSet) 在 Redis 中是通过 "跳表(Skip List)" 和 "哈希表(Hash Table)" 两种数据结构共同实现的。

跳表(Skip List):

- 跳表是有序集合类型的核心数据结构,用于实现元素的有序排列和快速查找。
- 跳表是一种类似于平衡树的数据结构,但是相比平衡树,跳表的实现更加简单,插入和删除操作也更加高效。
- 跳表通过维护多层索引,每一层索引都是一个有序链表,高层索引是低层索引的子集。通过跳表,可以快速地定位到目标元素所在的位置。

哈希表(Hash Table):

- 除了跳表,有序集合类型还使用哈希表来存储元素的成员(member)和分数(score)之间的映射关系。
- 哈希表通过将成员作为键(key),分数作为值(value)进行存储,实现了快速查找某个成员对应的分数。
- 哈希表的作用是辅助跳表,提供了 O(1) 时间复杂度的元素查找能力。

跳表和哈希表的结合使得有序集合类型在 Redis 中能够高效地支持以下操作:

- 根据分数范围查找元素
- 根据成员查找分数
- 根据分数排名查找元素
- 快速插入和删除元素

因此,我之前提到 "有序集合类型使用散列表实现" 是不完全准确的,应该是 "有序集合类型使用跳表和哈希表共同实现"。跳表负责实现元素的有序性和范围查找,哈希表负责实现成员和分数的映射关系,二者协同工作,提供了有序集合类型的高性能。

### SortedSet和List的区别

相似点

- 二者都是有序的，List是按数据插入顺序，SortedSet是根据score自然排序
- 二者都可以获得某一范围的元素

区别

- 列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢
- 有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快
- 列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现）
- 有序集合要比列表类型更耗内存

### 命令

```shell
ZADD key score member [score member ...]
ZREM key member [member ...] 

127.0.0.1:6379> zadd scoreboard 80 zhangsan 89 lisi 94 wangwu
(integer) 3
127.0.0.1:6379> zadd scoreboard 97 lisi
(integer) 0
127.0.0.1:6379> zrem scoreboard lisi
(integer) 1

#zrange/zrevrange 获取范围元素列表
#获得排名在某个范围的元素列表。

#ZRANGE：按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素）
#ZREVRANGE：按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）

# 如果需要获得元素的分数的可以在命令尾部加上 WITHSCORES 参数
ZRANGE key start stop [WITHSCORES] 
ZREVRANGE key start stop [WITHSCORES]
127.0.0.1:6379> zrange scoreboard 0 2
1) "zhangsan"
2) "wangwu"
3) "lisi“
127.0.0.1:6379> zrevrange scoreboard 0 2
1) "lisi"
2) "wangwu"
3) "zhangsan“

#zscore 获取元素的分数
ZSCORE key member
127.0.0.1:6379> zscore scoreboard lisi
"97"

# 获得指定分数范围的元素
ZRANGEBYSCORE key min max [WITHSCORES] 
# 增加某个元素的分数
ZINCRBY key increment member
# 获得集合中元素的数量
ZCARD key
# 获得指定分数范围内的元素个数
ZCOUNT key min max
# 按照排名范围删除元素
ZREMRANGEBYRANK key start stop
# 按照分数范围删除元素
ZREMRANGEBYSCORE key min max
# 获取元素的排名 
# - ZRANK：从小到大
# - ZREVRANK：从大到小
ZRANK key member
ZREVRANK key member
```

### 使用场景

- 存放一个有序的并且不重复的集合列表
- 排行榜相关，取TOP N操作

## 通用命令

```shell
# 返回满足规则的key-value
KEYS pattern
127.0.0.1:6379> keys k*
1) "k1"
2) "k3"
3) "k2"
4) "key"

#del 删除
DEL key [key ...] 
127.0.0.1:6379> del k1 k2 k3
(integer) 3

#exists 是否存在
127.0.0.1:6379> exists test
(integer) 1
127.0.0.1:6379> exists mytest
(integer) 0

#expires 生存时间设置
# 设置过期时间（单位：秒）
EXPIRES key seconds  
# 设置过期时间（单位：毫秒）
PEXPIRES key milliseconds 
# 查看key剩余的生存时间
TTL key
PTTL key
# 清除生存时间
PERSIST key

#rename 重命名
RENAME key newkey

#type 查看数据类型
redis 127.0.0.1:6379> type addr
string
redis 127.0.0.1:6379> type myzset2
zset
redis 127.0.0.1:6379> type mylist
list
```

## Stream和ReJson

1. STREAM (Redis 5.0新增):
   - STREAM 是 Redis 5.0 引入的一种新的数据类型,用于支持消息队列和流式处理。
   - STREAM 提供了一种抽象的日志数据结构,允许生产者(producers)向其中追加条目(entries),消费者(consumers)可以阻塞等待新条目的到来。
   - 每个条目都有一个唯一的 ID,ID 由时间戳和序列号组成,保证了条目的有序性和唯一性。
   - STREAM 支持消费者组(consumer groups),允许多个消费者协同处理同一个流中的条目,实现消息的分发和负载均衡。
   - STREAM 还提供了一些高级特性,如消息的 ACK 机制、消息的阻塞读取、消息的范围读取等。
   - STREAM 适用于实现消息队列、事件驱动系统、实时数据处理等场景。

2. ReJSON (Redis 模块):
   - ReJSON 是一个 Redis 模块,用于在 Redis 中存储和操作 JSON 数据。
   - ReJSON 允许将 JSON 文档直接存储在 Redis 的键值对中,提供了一组命令用于对 JSON 数据进行操作。
   - ReJSON 支持对 JSON 文档进行读取、修改、删除等操作,还支持对 JSON 文档的属性进行索引和查询。
   - ReJSON 使用 Redis 的数据结构来表示 JSON,如字符串、列表、哈希表等,从而实现了高效的 JSON 存储和访问。
   - ReJSON 提供了 JSON Path 的支持,允许使用类似于文件路径的语法对 JSON 文档进行查询和操作。
   - ReJSON 的优点是将 JSON 数据与 Redis 的高性能结合起来,适用于需要频繁读写 JSON 数据的场景,如缓存、配置存储、实时数据处理等。

需要注意的是,ReJSON 不是 Redis 内置的数据类型,而是一个单独的模块,需要额外安装和启用。而 STREAM 是 Redis 5.0 版本引入的内置数据类型,可以直接使用。

这两种数据类型扩展了 Redis 的功能,STREAM 用于支持消息队列和流式处理,ReJSON 用于存储和操作 JSON 数据,它们都有其特定的应用场景和使用方式。根据实际的需求和项目特点,可以选择使用 STREAM 或 ReJSON 来满足相应的数据存储和处理需求。

## 三种特殊的数据结构

| 数据类型         | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| Bitmap           | 你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。 |
| HyperLogLog      | Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近`2^64`个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 `0.81%` ）。 |
| Geospatial index | Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。 |

## 底层数据结构

好的,我来分别描述一下 Redis 中 5 种主要数据类型的底层实现数据结构:

STRING (字符串):
- 底层实现:动态字符串(Simple Dynamic String, SDS)
- SDS 是 Redis 自己实现的一种字符串表示,与 C 语言中的字符串相比,SDS 具有长度信息,可以在 O(1) 时间复杂度内获取字符串长度。
- SDS 采用预分配空间的策略,当字符串长度小于 1M 时,每次扩容都会多分配一倍的空间,当字符串长度超过 1M 时,每次扩容会多分配 1M 的空间。这种策略可以减少内存重分配的次数。
- SDS 支持惰性空间释放,即字符串缩短时,不会立即释放多余的空间,而是等待后续使用。这样可以避免频繁的内存分配和释放操作。

LIST (列表):
- 底层实现:快速列表(Quicklist)
- 快速列表是 Redis 3.2 版本引入的一种数据结构,结合了双向链表和压缩列表(Ziplist)的优点。
- 快速列表由多个压缩列表组成,每个压缩列表中存储了一部分元素。
- 当元素数量较少时,快速列表会使用一个压缩列表来存储所有元素,以节省内存空间。
- 当元素数量较多时,快速列表会将元素分散存储在多个压缩列表中,通过双向链表将这些压缩列表连接起来。
- 快速列表通过将元素分散存储,可以在保持较低内存使用的同时,提供了较高的插入和删除性能。

HASH (哈希):
- 底层实现:压缩列表(Ziplist)或哈希表(Hash Table)
- 当哈希类型中的元素数量较少且字符串长度较短时,Redis 会使用压缩列表来存储键值对。压缩列表是一种紧凑的数据结构,通过连续的内存空间存储元素,节省内存占用。
- 当哈希类型中的元素数量较多或字符串长度较长时,Redis 会使用哈希表来存储键值对。哈希表采用数组加链表的方式解决冲突,提供了 O(1) 的平均查找时间复杂度。
- Redis 会根据哈希类型的元素数量和字符串长度动态选择使用压缩列表还是哈希表,以平衡内存使用和查找性能。

SET (集合):
- 底层实现:整数集合(Intset)或哈希表(Hash Table)
- 当集合中的元素都是整数且元素数量较少时,Redis 会使用整数集合来存储。整数集合是一种紧凑的数据结构,通过连续的内存空间存储整数元素,节省内存占用。
- 当集合中的元素不全是整数或元素数量较多时,Redis 会使用哈希表来存储。哈希表采用数组加链表的方式解决冲突,提供了 O(1) 的平均查找时间复杂度。
- Redis 会根据集合的元素类型和数量动态选择使用整数集合还是哈希表,以平衡内存使用和查找性能。

ZSET (有序集合):
- 底层实现:跳跃表(Skip List)和哈希表(Hash Table)
- 有序集合使用跳跃表来维护元素的有序性,跳跃表是一种随机化的数据结构,通过维护多级索引提供了 O(log N) 的平均查找和插入时间复杂度。
- 同时,有序集合使用哈希表来存储元素的成员(member)和分值(score)之间的映射关系,哈希表提供了 O(1) 的平均查找时间复杂度。
- 跳跃表和哈希表的结合使得有序集合能够高效地支持范围查询和排名查询,同时保证了元素的唯一性。

压缩列表(Ziplist)是 Redis 中的一种紧凑的数据结构,用于存储字符串或整数元素。它是一个连续的内存块,通过特殊的编码方式来节省内存空间。

压缩列表的主要特点如下:

1. 内存紧凑:压缩列表通过一系列编码和压缩技术,将元素紧密地存储在连续的内存空间中,减少了内存的浪费。它避免了像链表那样每个元素都需要单独的内存块,从而节省了内存占用。

2. 可变长度:压缩列表支持存储不同长度的字符串和整数元素。它使用不同的编码方式来表示不同长度的元素,例如:
   - 对于小于等于 63 字节的字符串,使用 1 字节长度的编码。
   - 对于小于等于 16383 字节的字符串,使用 2 字节长度的编码。
   - 对于小于等于 4294967295 字节的字符串,使用 5 字节长度的编码。
   - 对于小整数(0-12),使用特殊的编码方式,只占用 1 字节。
   - 对于大整数,使用整数的二进制编码方式进行存储。

3. 连续存储:压缩列表中的元素是连续存储的,没有任何间隔或额外的元数据。每个元素紧跟着前一个元素,形成一个紧凑的内存块。这种连续存储的方式可以提高缓存的局部性,加快访问速度。

4. 双向遍历:尽管压缩列表是连续存储的,但它同时支持双向遍历。通过特殊的编码方式,压缩列表可以从头部或尾部开始遍历元素,并快速定位到下一个元素的位置。

5. 动态调整:当压缩列表的长度或元素大小超过一定阈值时,Redis 会自动将压缩列表转换为其他的数据结构,如链表或哈希表。这种动态调整机制可以在不同的场景下优化性能和内存使用。

压缩列表通常用于存储少量元素的列表、哈希或有序集合。当元素数量较少且元素长度较小时,使用压缩列表可以显著减少内存的使用。但是,当元素数量或长度增大时,压缩列表的查找和修改操作的时间复杂度会变高,因为需要进行解码和重新编码。

总之,压缩列表是 Redis 为了节省内存而设计的一种紧凑的数据结构。它通过编码和压缩技术,将元素紧密地存储在连续的内存空间中,并支持双向遍历和动态调整。在适当的场景下使用压缩列表可以显著减少内存的占用,提高 Redis 的存储效率。

以上就是 Redis 中 5 种主要数据类型的底层实现数据结构。Redis 通过选择合适的数据结构,在内存使用和查找性能之间进行平衡,提供了高效的数据存储和访问能力。同时,Redis 还会根据数据的特点和规模动态调整底层数据结构,以优化性能和内存使用。

