# Redis概述

[Redis介绍、安装以及数据结构(操作命令) - 掘金 (juejin.cn)](https://juejin.cn/post/6844903910579109896)

使用C语言开发的高性能**键值对k-v内存数据库，可以用作数据库，缓存和消息中间件**。它是一种**NoSQL非关系型数据库**。

- 内存数据库，读写快。支持并发10W QPS。
- ❗️❗️❗️单进程单线程，线程安全，采用IO多路复用。
- 丰富的数据结构。
- 支持数据持久化，将内存中数据保存在磁盘中，重启时加载。
- 主从复制。
- ❗️❗️❗️Redis的部署

# Redis的应用场景

- **内存数据库**（登录信息、购物车信息、用户浏览记录等）
- **缓存服务器**（商品数据、广告数据等等）（**最多使用**）
- 解决分布式集群架构中的 session 分离问题（ session 共享）
- 任务队列（秒杀、抢购、12306等等）
- 分布式锁的实现
- 支持发布订阅的消息模式
- 应用排行榜(有序集合)
- 网站访问统计
- 数据过期处理（可以精确到毫秒）

# Redis作为内存数据库和缓存服务器

Redis 作为一个高性能的键值对存储系统,可以同时扮演内存数据库和缓存服务器的角色。它们之间的主要区别在于数据的持久性和用途。让我通过以下几点来帮助你理解和区分 Redis 作为内存数据库和缓存服务器的特点:

## 数据持久性:

- 内存数据库:当 Redis 作为内存数据库使用时,数据的持久性是关键。Redis 提供了持久化的功能,可以将内存中的数据以快照(RDB)或追加(AOF)的方式持久化到磁盘上。这样即使 Redis 重启或崩溃,数据也不会丢失,可以从持久化文件中恢复。
- 缓存服务器:当 Redis 作为缓存服务器使用时,数据的持久性通常不是必需的。缓存服务器的目的是提供快速的数据访问,而不是长期存储数据。如果 Redis 重启或崩溃,缓存数据可以从原始数据源(如数据库)重新加载。

## 数据一致性:

- 内存数据库:作为内存数据库,Redis 需要确保数据的一致性和可靠性。数据的更新和删除操作需要及时持久化到磁盘,以保证数据的完整性。Redis 提供了事务和 Lua 脚本等功能,可以支持复杂的数据操作和保证数据的一致性。
- 缓存服务器:作为缓存服务器,Redis 的数据一致性要求相对较低。缓存的目的是提高性能,而不是保证数据的绝对一致性。缓存的数据可能与原始数据源存在一定的延迟或不一致,但这通常是可以接受的,因为缓存的数据可以随时从原始数据源更新。

## 数据访问模式:

- 内存数据库:作为内存数据库,Redis 通常用于存储和访问应用程序的关键数据。数据的读写操作频繁,且对性能要求较高。Redis 提供了丰富的数据类型和操作命令,可以支持复杂的数据结构和查询需求。
- 缓存服务器:作为缓存服务器,Redis 主要用于缓存频繁访问的数据,以减轻后端数据库的负载。缓存的数据通常是只读的,或者是短时间内不会发生变化的。Redis 的高速读取性能使其非常适合作为缓存服务器,可以显著提高应用程序的响应速度。

## 数据量和内存占用:

- 内存数据库:作为内存数据库,Redis 需要将所有数据都存储在内存中,因此内存占用较高。Redis 的数据量受限于可用的内存大小。如果数据量超出内存容量,需要进行数据的持久化和转储。
- 缓存服务器:作为缓存服务器,Redis 只缓存最频繁访问的数据子集。缓存的数据量相对较小,内存占用较低。当缓存空间不足时,可以使用缓存淘汰策略(如 LRU)自动删除最近最少使用的缓存数据,以腾出空间给新的缓存数据。

通过以上的对比,你可以看到 Redis 在作为内存数据库和缓存服务器时的不同侧重点和特点。内存数据库强调数据的持久性、一致性和复杂的数据操作,而缓存服务器侧重于提供高速的数据访问和缓解后端数据库的压力。

在实际应用中,Redis 可以根据业务需求和系统架构,灵活地扮演内存数据库或缓存服务器的角色,或者同时兼顾两者。理解 Redis 在不同场景下的特点和用途,可以帮助你更好地利用 Redis 的功能和优势,设计出高性能、可扩展的应用程序。

# Redis的数据结构以及操作命令

## 字符串String

### 命令

```shell
# 赋值
SET key value [EX seconds] [PX milliseconds] [NX|XX]

# 取值 
GET key

# 设置新值，返回旧值
GETSET key value

EX seconds：键过期时间
PX milliseconds：为键设置毫秒级过期时间
NX：键必须不存在才可以设置成功，用于添加
XX：键必须存在，才可以设置成功，用于更新

#当value值为整数时，才可以使用数值增减命令，incr/decr为增加/减少1，incrby/decrby为增加/减少具体的数值，数值的增减是原子操作。
127.0.0.1:6379> set counter 100
OK
127.0.0.1:6379> incr counter
(integer) 101
127.0.0.1:6379> incrby counter 20
(integer) 121
127.0.0.1:6379> decr counter
(integer) 120
127.0.0.1:6379> decrby counter 10
(integer) 110

#mset/mget 同时设置/获取多个键值 在单个命令中设置/获取多个键值是可以减少延迟的
127.0.0.1:6379> mset k1 10 k2 20 k3 30
OK
127.0.0.1:6379> mget k1 k2 k3
1) "10"
2) "20"
3) "30"
```

### 使用场景

- 黑名单IP的计数器(nginx设置黑名单deny IP)

- 常规的key-value缓存
- 计数：微博数、粉丝数等
- 应用INCR原子计数生产全局唯一id或单号

## 散列Hash

### 命令

```shell
# 设置一个字段值
HSET key field value 
# 设置多个字段值
HMSET key field value [field value ...]
# 字段不存在时赋值
HMSETNX key field value
# 获取一个字段值
HGET key field 
# 获取多个字段值
HMGET key field [field ...] 
# 获取所有字段值
HGETALL key

127.0.0.1:6379> hmset user name zou age 23
OK
127.0.0.1:6379> hset user location Guangzhou
(integer) 1
127.0.0.1:6379> hget user name
"zou"
127.0.0.1:6379> hgetall user
1) "name"
2) "zou"
3) "age"
4) "23"
5) "location"
6) "Guangzhou"

127.0.0.1:6379> hincrby user age 1
(integer) 24


# 判断字段是否存在
HEXISTS key field
# 只获取字段名
HKEYS key
# 只获取字段值
HVALS key
# 获取字段数量
HLEN key
# 获取所有字段和值
HGETALL key
```

### String和Hash的区别

Hash类型适合存储那些对象数据，特别是对象属性经常发生【增删改】操作的数据。 String类型也可以存储对象数据，将Java对象转成json字符串或序列化进行存储，这种存储适合【查询】操作。

### 使用场景

- 存储结构化数据对象，如用户信息、商品信息。


## 列表List

Redis的列表是链表结构的，可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1) ，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。

### 命令

```shell
# 列表的左端添加元素
LPUSH key value [value ...]
# 列表的右端添加元素
RPUSH key value [value ...]
127.0.0.1:6379> lpush list:1 1 2 3 
(integer) 3 
127.0.0.1:6379> rpush list:1 4 5 6 
(integer) 3 

#lrange 获取列表片段
#获取列表中的某一片段，返回start、stop之间的所有元素（包含两端的元素），索引从0开始，索引可以是负数，表明从结尾开始计数：所以-1是最后一个元素，-2是列表的倒数第二个元素
127.0.0.1:6379> lrange  list:1 0 2 
1) "2" 
2) "1" 
3) "4"

#lpop/rpop 从列表两端弹出元素
#从列表两端弹出一个元素，会分两步完成：
#第一步是将列表左边的元素从列表中移除
#第二步是返回被移除的元素值
LPOP key
RPOP key
127.0.0.1:6379>lpop list:1 
"3“ 
127.0.0.1:6379>rpop list:1 
"6“

# 获取列表中元素的个数
LLEN key
# 删除列表中指定个数的值
# - 当count>0时， LREM会从列表左边开始删除。
# - 当count<0时， LREM会从列表后边开始删除。
# - 当count=0时， LREM删除所有值为value的元素
LREM key count value
# 获取指定索引的元素值
LINDEX key index
# 只保留列表指定片段,指定范围和lrange一致
LTRIM key start stop
# 向列表中插入元素
LINSERT key BEFORE|AFTER pivot value
# 将元素从一个列表转移到另一个列表中
RPOPLPUSH source destination
```

### 使用场景

- 各种列表：关注列表、粉丝列表、评论
- 消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出执行。简易的队列，管道模式。
- 利用LRANGE可以很方便的实现list内容分页的功能
- 取最新N个数据的操作

## 集合Set

Set是字符串的无序集合，其中的数据是**不重复**且**没有顺序**，集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为 0(1)，Redis 还提供了多个集合之间的交集、并集、差集的运算。

### 命令

```shell
#sadd/srem 添加/删除元素
SADD key member [member ...]
SREM key member [member ...]

127.0.0.1:6379> sadd set a b c 
(integer) 3 
127.0.0.1:6379> sadd set a 
(integer) 0 
127.0.0.1:6379> srem set c d 
(integer) 1 

#smembers 获取所有元素
SMEMBERS key 

# 判断元素是否在集合中, 返回1为在，0为不在
SISMEMBER key member

#SDIFF - 集合的差集运算 A-B：属于A并且不属于B的元素构成的集合
127.0.0.1:6379> sadd setA 1 2 3
(integer) 3
127.0.0.1:6379> sadd setB 2 3 4
(integer) 3
127.0.0.1:6379> sdiff setA setB
1) "1"
127.0.0.1:6379> sdiff setB setA
1) "4"

#SINTER - 集合的交集运算 A ∩ B：属于A且属于B的元素构成的集合
127.0.0.1:6379> sinter setA setB
1) "2"
2) "3"

#SUNION - 集合的并集运算 A ∪ B：属于A或者属于B的元素构成的集合
127.0.0.1:6379> sunion setA setB
1) "1"
2) "2"
3) "3"
4) "4"

# 获得集合中元素的个数
SCARD key
# 从集合中随机弹出一个元素
SPOP key
```

### 使用场景

- 需要去重的列表。
- 提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能。

## 有序集合ZSET

有序集合（Sorted Set，zset）在Set集合类型的基础上，有序集合类型为集合中的每个元素都关联一个分数(score) ，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。

### 实现

有序集合类型 (SortedSet) 在 Redis 中是通过 "跳表(Skip List)" 和 "哈希表(Hash Table)" 两种数据结构共同实现的。

跳表(Skip List):

- 跳表是有序集合类型的核心数据结构,用于实现元素的有序排列和快速查找。
- 跳表是一种类似于平衡树的数据结构,但是相比平衡树,跳表的实现更加简单,插入和删除操作也更加高效。
- 跳表通过维护多层索引,每一层索引都是一个有序链表,高层索引是低层索引的子集。通过跳表,可以快速地定位到目标元素所在的位置。

哈希表(Hash Table):

- 除了跳表,有序集合类型还使用哈希表来存储元素的成员(member)和分数(score)之间的映射关系。
- 哈希表通过将成员作为键(key),分数作为值(value)进行存储,实现了快速查找某个成员对应的分数。
- 哈希表的作用是辅助跳表,提供了 O(1) 时间复杂度的元素查找能力。

跳表和哈希表的结合使得有序集合类型在 Redis 中能够高效地支持以下操作:

- 根据分数范围查找元素
- 根据成员查找分数
- 根据分数排名查找元素
- 快速插入和删除元素

因此,我之前提到 "有序集合类型使用散列表实现" 是不完全准确的,应该是 "有序集合类型使用跳表和哈希表共同实现"。跳表负责实现元素的有序性和范围查找,哈希表负责实现成员和分数的映射关系,二者协同工作,提供了有序集合类型的高性能。

### SortedSet和List的区别

相似点

- 二者都是有序的，List是按数据插入顺序，SortedSet是根据score自然排序
- 二者都可以获得某一范围的元素

区别

- 列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢
- 有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快
- 列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现）
- 有序集合要比列表类型更耗内存

### 命令

```shell
ZADD key score member [score member ...]
ZREM key member [member ...] 

127.0.0.1:6379> zadd scoreboard 80 zhangsan 89 lisi 94 wangwu
(integer) 3
127.0.0.1:6379> zadd scoreboard 97 lisi
(integer) 0
127.0.0.1:6379> zrem scoreboard lisi
(integer) 1

#zrange/zrevrange 获取范围元素列表
#获得排名在某个范围的元素列表。

#ZRANGE：按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素）
#ZREVRANGE：按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）

# 如果需要获得元素的分数的可以在命令尾部加上 WITHSCORES 参数
ZRANGE key start stop [WITHSCORES] 
ZREVRANGE key start stop [WITHSCORES]
127.0.0.1:6379> zrange scoreboard 0 2
1) "zhangsan"
2) "wangwu"
3) "lisi“
127.0.0.1:6379> zrevrange scoreboard 0 2
1) "lisi"
2) "wangwu"
3) "zhangsan“

#zscore 获取元素的分数
ZSCORE key member
127.0.0.1:6379> zscore scoreboard lisi
"97"

# 获得指定分数范围的元素
ZRANGEBYSCORE key min max [WITHSCORES] 
# 增加某个元素的分数
ZINCRBY key increment member
# 获得集合中元素的数量
ZCARD key
# 获得指定分数范围内的元素个数
ZCOUNT key min max
# 按照排名范围删除元素
ZREMRANGEBYRANK key start stop
# 按照分数范围删除元素
ZREMRANGEBYSCORE key min max
# 获取元素的排名 
# - ZRANK：从小到大
# - ZREVRANK：从大到小
ZRANK key member
ZREVRANK key member
```

### 使用场景

- 存放一个有序的并且不重复的集合列表
- 排行榜相关，取TOP N操作

## 通用命令

```shell
# 返回满足规则的key-value
KEYS pattern
127.0.0.1:6379> keys k*
1) "k1"
2) "k3"
3) "k2"
4) "key"

#del 删除
DEL key [key ...] 
127.0.0.1:6379> del k1 k2 k3
(integer) 3

#exists 是否存在
127.0.0.1:6379> exists test
(integer) 1
127.0.0.1:6379> exists mytest
(integer) 0

#expires 生存时间设置
# 设置过期时间（单位：秒）
EXPIRES key seconds  
# 设置过期时间（单位：毫秒）
PEXPIRES key milliseconds 
# 查看key剩余的生存时间
TTL key
PTTL key
# 清除生存时间
PERSIST key

#rename 重命名
RENAME key newkey

#type 查看数据类型
redis 127.0.0.1:6379> type addr
string
redis 127.0.0.1:6379> type myzset2
zset
redis 127.0.0.1:6379> type mylist
list
```

## Stream和ReJson

1. STREAM (Redis 5.0新增):
   - STREAM 是 Redis 5.0 引入的一种新的数据类型,用于支持消息队列和流式处理。
   - STREAM 提供了一种抽象的日志数据结构,允许生产者(producers)向其中追加条目(entries),消费者(consumers)可以阻塞等待新条目的到来。
   - 每个条目都有一个唯一的 ID,ID 由时间戳和序列号组成,保证了条目的有序性和唯一性。
   - STREAM 支持消费者组(consumer groups),允许多个消费者协同处理同一个流中的条目,实现消息的分发和负载均衡。
   - STREAM 还提供了一些高级特性,如消息的 ACK 机制、消息的阻塞读取、消息的范围读取等。
   - STREAM 适用于实现消息队列、事件驱动系统、实时数据处理等场景。

2. ReJSON (Redis 模块):
   - ReJSON 是一个 Redis 模块,用于在 Redis 中存储和操作 JSON 数据。
   - ReJSON 允许将 JSON 文档直接存储在 Redis 的键值对中,提供了一组命令用于对 JSON 数据进行操作。
   - ReJSON 支持对 JSON 文档进行读取、修改、删除等操作,还支持对 JSON 文档的属性进行索引和查询。
   - ReJSON 使用 Redis 的数据结构来表示 JSON,如字符串、列表、哈希表等,从而实现了高效的 JSON 存储和访问。
   - ReJSON 提供了 JSON Path 的支持,允许使用类似于文件路径的语法对 JSON 文档进行查询和操作。
   - ReJSON 的优点是将 JSON 数据与 Redis 的高性能结合起来,适用于需要频繁读写 JSON 数据的场景,如缓存、配置存储、实时数据处理等。

需要注意的是,ReJSON 不是 Redis 内置的数据类型,而是一个单独的模块,需要额外安装和启用。而 STREAM 是 Redis 5.0 版本引入的内置数据类型,可以直接使用。

这两种数据类型扩展了 Redis 的功能,STREAM 用于支持消息队列和流式处理,ReJSON 用于存储和操作 JSON 数据,它们都有其特定的应用场景和使用方式。根据实际的需求和项目特点,可以选择使用 STREAM 或 ReJSON 来满足相应的数据存储和处理需求。

## 三种特殊的数据结构

| 数据类型         | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| Bitmap           | 你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。 |
| HyperLogLog      | Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近`2^64`个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 `0.81%` ）。 |
| Geospatial index | Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。 |

## 底层数据结构

好的,我来分别描述一下 Redis 中 5 种主要数据类型的底层实现数据结构:

STRING (字符串):
- 底层实现:动态字符串(Simple Dynamic String, SDS)
- SDS 是 Redis 自己实现的一种字符串表示,与 C 语言中的字符串相比,SDS 具有长度信息,可以在 O(1) 时间复杂度内获取字符串长度。
- SDS 采用预分配空间的策略,当字符串长度小于 1M 时,每次扩容都会多分配一倍的空间,当字符串长度超过 1M 时,每次扩容会多分配 1M 的空间。这种策略可以减少内存重分配的次数。SDS 的初始容量与字符串的初始长度 `initlen` 相等。也就是说,SDS 会根据传入的初始字符串长度来分配恰好容纳该字符串的内存空间。
- SDS 支持惰性空间释放,即字符串缩短时,不会立即释放多余的空间,而是等待后续使用。这样可以避免频繁的内存分配和释放操作。

LIST (列表):
- 底层实现:快速列表(Quicklist)
- 快速列表是 Redis 3.2 版本引入的一种数据结构,结合了双向链表和压缩列表(Ziplist)的优点。
- 快速列表由多个压缩列表组成,每个压缩列表中存储了一部分元素。
- 当元素数量较少时,快速列表会使用一个压缩列表来存储所有元素,以节省内存空间。
- 当元素数量较多时,快速列表会将元素分散存储在多个压缩列表中,通过双向链表将这些压缩列表连接起来。
- 快速列表通过将元素分散存储,可以在保持较低内存使用的同时,提供了较高的插入和删除性能。

HASH (哈希):
- 底层实现:压缩列表(Ziplist)或哈希表(Hash Table)
- 当哈希类型中的元素数量较少且字符串长度较短时,Redis 会使用压缩列表来存储键值对。压缩列表是一种紧凑的数据结构,通过连续的内存空间存储元素,节省内存占用。
- 当哈希类型中的元素数量较多或字符串长度较长时,Redis 会使用哈希表来存储键值对。哈希表采用数组加链表的方式解决冲突,提供了 O(1) 的平均查找时间复杂度。
- Redis 会根据哈希类型的元素数量和字符串长度动态选择使用压缩列表还是哈希表,以平衡内存使用和查找性能。
- 在 Redis 中,哈希类型的底层实现会根据元素数量和字符串长度动态选择使用压缩列表(Ziplist)还是哈希表(Hash Table)。这个阈值可以通过配置参数来调整,默认值如下:

  1. 元素数量阈值:
     - 当哈希类型中的元素数量小于等于 `hash-max-ziplist-entries` 配置参数时,Redis 会使用压缩列表来存储键值对。
     - 默认情况下,`hash-max-ziplist-entries` 的值为 512。即当哈希类型的元素数量小于等于 512 时,使用压缩列表。
  2. 字符串长度阈值:
     - 当哈希类型中的所有字符串元素的长度都小于等于 `hash-max-ziplist-value` 配置参数时,Redis 会使用压缩列表来存储键值对。
     - 默认情况下,`hash-max-ziplist-value` 的值为 64。即当哈希类型中的所有字符串元素的长度都小于等于 64 字节时,使用压缩列表。

  只有当同时满足以上两个条件时,Redis 才会使用压缩列表来存储哈希类型的键值对。如果超过了其中任意一个阈值,Redis 就会将压缩列表转换为哈希表来存储键值对。

SET (集合):
- 底层实现:整数集合(Intset)或哈希表(Hash Table)
- 当集合中的元素都是整数且元素数量较少时,Redis 会使用整数集合来存储。整数集合是一种紧凑的数据结构,通过连续的内存空间存储整数元素,节省内存占用。
- 当集合中的元素不全是整数或元素数量较多时,Redis 会使用哈希表来存储。哈希表采用数组加链表的方式解决冲突,提供了 O(1) 的平均查找时间复杂度。
- Redis 会根据集合的元素类型和数量动态选择使用整数集合还是哈希表,以平衡内存使用和查找性能。

ZSET (有序集合):
- 底层实现:跳跃表(Skip List)和哈希表(Hash Table)
- 有序集合使用跳跃表来维护元素的有序性,跳跃表是一种随机化的数据结构,通过维护多级索引提供了 O(log N) 的平均查找和插入时间复杂度。
- 同时,有序集合使用哈希表来存储元素的成员(member)和分值(score)之间的映射关系,哈希表提供了 O(1) 的平均查找时间复杂度。
- 跳跃表和哈希表的结合使得有序集合能够高效地支持范围查询和排名查询,同时保证了元素的唯一性。

压缩列表(Ziplist)是 Redis 中的一种紧凑的数据结构,用于存储字符串或整数元素。它是一个连续的内存块,通过特殊的编码方式来节省内存空间。

压缩列表的主要特点如下:

1. 内存紧凑:压缩列表通过一系列编码和压缩技术,将元素紧密地存储在连续的内存空间中,减少了内存的浪费。它避免了像链表那样每个元素都需要单独的内存块,从而节省了内存占用。

2. 可变长度:压缩列表支持存储不同长度的字符串和整数元素。它使用不同的编码方式来表示不同长度的元素,例如:
   - 对于小于等于 63 字节的字符串,使用 1 字节长度的编码。
   - 对于小于等于 16383 字节的字符串,使用 2 字节长度的编码。
   - 对于小于等于 4294967295 字节的字符串,使用 5 字节长度的编码。
   - 对于小整数(0-12),使用特殊的编码方式,只占用 1 字节。
   - 对于大整数,使用整数的二进制编码方式进行存储。

3. 连续存储:压缩列表中的元素是连续存储的,没有任何间隔或额外的元数据。每个元素紧跟着前一个元素,形成一个紧凑的内存块。这种连续存储的方式可以提高缓存的局部性,加快访问速度。

4. 双向遍历:尽管压缩列表是连续存储的,但它同时支持双向遍历。通过特殊的编码方式,压缩列表可以从头部或尾部开始遍历元素,并快速定位到下一个元素的位置。

5. 动态调整:当压缩列表的长度或元素大小超过一定阈值时,Redis 会自动将压缩列表转换为其他的数据结构,如链表或哈希表。这种动态调整机制可以在不同的场景下优化性能和内存使用。

压缩列表通常用于存储少量元素的列表、哈希或有序集合。当元素数量较少且元素长度较小时,使用压缩列表可以显著减少内存的使用。但是,当元素数量或长度增大时,压缩列表的查找和修改操作的时间复杂度会变高,因为需要进行解码和重新编码。

总之,压缩列表是 Redis 为了节省内存而设计的一种紧凑的数据结构。它通过编码和压缩技术,将元素紧密地存储在连续的内存空间中,并支持双向遍历和动态调整。在适当的场景下使用压缩列表可以显著减少内存的占用,提高 Redis 的存储效率。

以上就是 Redis 中 5 种主要数据类型的底层实现数据结构。Redis 通过选择合适的数据结构,在内存使用和查找性能之间进行平衡,提供了高效的数据存储和访问能力。同时,Redis 还会根据数据的特点和规模动态调整底层数据结构,以优化性能和内存使用。

# Redis持久化机制AOF和RDB

## RDB快照持久化

RDB是默认的持久化方式。指定的时间间隔内备份内存中的数据集写入磁盘。可以将快照复制到其他服务器以创建相同数据的服务器副本，或者在重启服务器后恢复数据。

## RDB文件

压缩过的二进制文件。redis的配置是dbfilename文件名 dir文件位置。

## RDB快照的时机和配置

- 执行save或者bgsave命令。
- 主从复制，从库全量复制同步主库，主库会执行bgsave。
- 执行flushall命令。
- 执行shutdown命令。

- 配置文件设置bgsave <seconds> <changes> 多少秒内至少有多少个key发生变话，就会自动触发bgsave。

## save和bgsave命令

save命令会阻塞Redis服务器进程，服务器进程在RDB文件创建完成之前不能处理任何的请求。

bgsave会fork一个子进程，该子进程负责创建RDB文件，服务器进程继续处理命令请求。

`fork`一个子进程，子进程会把数据集先写入临时文件，写入成功之后，再替换之前的RDB文件，用二进制压缩存储，这样可以保证RDB文件始终存储的是完整的持久化内容。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/10/16d1a887a8ba96ea~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

## AOF持久化

AOF持久化会把被执行的命令写到AOF文件的末尾，记录数据的变化。

## AOF持久化的配置

```shell
# appendonly参数开启AOF持久化
appendonly no

# AOF持久化的文件名，默认是appendonly.aof
appendfilename "appendonly.aof"

# AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的
dir ./

# 同步策略
# appendfsync always
appendfsync everysec
# appendfsync no

# aof重写期间是否同步
no-appendfsync-on-rewrite no

# 重写触发配置
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 加载aof出错如何处理
aof-load-truncated yes

# 文件重写策略
aof-rewrite-incremental-fsync yes

```

## AOF的实现

### 命令追加append

服务器每执行一个命令，都会以协议格式追加到aof_buf缓冲区的末尾，而非直接写入文件，减少磁盘IO。

### 文件写入write和文件同步sync

#### appendsync alwasys

将aof_buf缓冲区的所有内容写入并同步到AOF文件，每个写命令同步写入磁盘。

#### appendsync everysec

将aof_buf缓冲区的所有内容写入并同步到AOF文件，每秒同步一次，由一个专门的线程负责。

#### appendsync no

将aof_buf缓冲区的所有内容写入并同步到AOF文件，同步时机由操作系统决定。当 AOF 缓冲区满或达到一定条件时,Redis 会将 AOF 缓冲区的内容写入到 AOF 文件中。

## AOF重写

AOF文件中存储的内容：该命令格式为Redis的序列化协议（RESP）。`*3`代表这个命令有三个参数，`$3`表示该参数长度为3。

AOF的冗余命令进行批处理，减少AOF文件的体积。AOF文件重写并不需要对现有的AOF文件进行任何读取、分享和写入操作，而是通过读取服务器当前的数据库状态来实现的。

文件重写的命令：bgrewriteaof

## AOF文件重写的流程

1. 重写会有大量的写入操作，所以服务器进程会fork一个子进程来创建一个新的AOF文件。
2. 在重写期间，服务器进程继续处理命令请求，如果有写入的命令，追加到aof_buf的同时，还会追加到aof_rewrite_bufAOF重写缓冲区。
3. 当子进程完成重写之后，会给父进程一个信号，然后父进程会把AOF重写缓冲区的内容写进新的AOF临时文件中，再对新的AOF文件改名完成替换，这样可以保证新的AOF文件与当前数据库数据的一致性。

## 混合持久化

1. Redis4.0开始支持RDB和AOF的混合持久化（可以通过配置项 aof-use-rdb-preamble 开启）
2. 如果是redis进程挂掉，那么重启redis进程即可，直接基于AOF日志文件恢复数据。
3. 如果是redis进程所在机器挂掉，那么重启机器后，尝试重启redis进程，尝试直接基于AOF日志文件进行数据恢复，如果AOF文件破损，那么用redis-check-aof fix命令修复。
4. 如果没有AOF文件，会去加载RDB文件。
5. 如果redis当前最新的AOF和RDB文件出现了丢失/损坏，那么可以尝试基于该机器上当前的某个最新的RDB数据副本进行数据恢复。

## RDB和AOF的对比



# 问题汇总

## Redis 作为内存数据库和缓存服务器

1. 当 Redis 作为内存数据库使用时,如何确保数据的持久性?Redis 提供了哪些持久化方式?它们之间有什么区别和优缺点?

   AOF和RDB。//TODO

2. 假设你正在开发一个电商网站,需要使用 Redis 作为内存数据库来存储用户的购物车信息。你会如何设计购物车的数据结构?如何保证数据的一致性和可靠性?

   key是购物车的常量标记+userId，value是购物车商品的列表。//TODO 一致性和可靠性

3. Redis 作为内存数据库时,如何处理数据量超出可用内存的情况?你有哪些策略和方法来应对这种情况?

   1. 数据分片(Sharding):
      1. 将数据划分为多个分片,每个分片存储在不同的 Redis 实例中。
      2. 通过将数据分散到多个 Redis 实例,可以将内存压力分摊到多个节点上,从而扩展内存容量。
      3. 可以使用一致性哈希算法或其他分片策略来确定数据的分布。
      4. 需要注意数据分片可能会带来数据查询和聚合的复杂性,需要在应用层进行处理。

   2. 数据淘汰策略:
      1. Redis 提供了多种数据淘汰策略,可以在内存不足时自动删除部分数据,以释放内存空间。
      2. 常见的数据淘汰策略有:
         - LRU(Least Recently Used):删除最近最少使用的数据。
         - LFU(Least Frequently Used):删除访问频率最低的数据。
         - TTL(Time To Live):删除已经过期的数据。
         - Random:随机删除数据。
      3. 可以根据数据的特点和业务需求,选择合适的淘汰策略,在内存不足时自动释放空间。

   3. 数据压缩:
      1. 对于一些冗余或可压缩的数据,可以采用压缩算法进行压缩存储,以减少内存占用。
      2. 常见的压缩算法有 LZF、GZIP 等,可以在存储数据时进行压缩,在读取数据时进行解压缩。
      3. 需要权衡压缩和解压缩的计算开销与节省的内存空间。

   4. 数据过期:
      1. 对于一些有时效性的数据,可以为其设置过期时间(TTL),当数据过期后自动删除,释放内存空间。
      2. 可以根据业务需求,为不同的数据设置合适的过期时间。
      3. 需要注意过期数据的删除策略,避免过期数据占用过多内存。

   5. 数据迁移:
      1. 当内存压力持续升高时,可以考虑将部分数据迁移到其他存储系统,如磁盘数据库或分布式缓存。
      2. 可以根据数据的访问频率和重要性,选择性地将冷数据迁移到其他存储,而将热数据保留在 Redis 内存中。
      3. 需要设计合适的数据迁移策略和机制,确保数据的一致性和可用性。

   6. 内存优化:
      1. 对 Redis 的配置参数进行优化,合理设置最大内存限制和内存回收策略。
      2. 使用精简的数据结构和编码方式,尽量减少内存的浪费。
      3. 避免存储大型的集合或对象,必要时可以考虑将其拆分为多个子集合或字段。

4. 当 Redis 作为缓存服务器使用时,如何保证缓存数据与后端数据库的一致性?你知道哪些缓存更新策略?它们各自的优缺点是什么?

5. 在使用 Redis 作为缓存服务器时,如何避免缓存穿透、缓存击穿和缓存雪崩等问题?请分别解释这三个问题,并提供相应的解决方案。

6. 假设你需要使用 Redis 作为缓存服务器来优化一个高并发的查询接口。你会如何设计缓存的键名结构和过期时间?如何保证缓存的命中率和查询性能?

7. Redis 作为缓存服务器时,如何选择合适的缓存淘汰策略?常见的缓存淘汰策略有哪些?它们各自的特点和适用场景是什么?

8. 在使用 Redis 作为缓存服务器时,如何监控和评估缓存的效果?你会关注哪些指标?如何分析和优化缓存的性能?

9. Redis 除了作为内存数据库和缓存服务器外,还可以用作消息队列。你能举一个实际的业务场景,说明 Redis 在消息队列方面的应用吗?

10. 在实际开发中,你是如何权衡和选择 Redis 作为内存数据库还是缓存服务器的?你会考虑哪些因素和指标来做出决策?
