# Nacos通信架构

## Nacos1.x的通信架构

![img](https://cdn.nlark.com/yuque/0/2022/png/22792614/1658677361289-62b4f2e0-f8dd-42e4-a71f-d4f9db92661b.png?x-oss-process=image%2Fresize%2Cw_954%2Climit_0)

### 通信模型

![image](https://github.com/huangjiahe/sundanwiki/assets/160099777/04b6d245-8b78-426e-a76a-683232ab74fd)


### Nacos Config 的推送模型

1. **Nacos Config 的推送模型**：Nacos Config 使用长轮询机制作为配置更新推送的方式，客户端发送请求到服务端询问配置是否有更新。如果没有，服务端会保持这个请求打开直到有更新或者超时，而不是立即返回响应。这种机制在高并发场景下提高了服务器的处理能力。

2. **异步Servlet的使用**：为了支持大量并发的长轮询请求，Nacos 使用了异步Servlet API，从而避免了传统同步处理模型中的线程阻塞。这使得服务端可以在不占用线程资源的情况下挂起和恢复HTTP请求，提高了高并发时的吞吐量和系统的可伸缩性。

3. **长轮询机制的特点**：在长轮询模式中，客户端的请求会保持打开状态，直到服务器有数据推送或者连接超时。这种机制可以减少服务器负载，减少响应延迟，并通过超时机制保持连接数可控。

4. **长轮询的默认超时时间**：Nacos 默认的长轮询超时时间通常设置为大约30秒。在这段时间内，如果服务端检测到配置的变化，它会立即响应挂起的请求。如果没有变化，当超时后，服务端会返回一个没有更新的响应。客户端在处理完响应之后，会在短暂的延迟后重新发起新的长轮询请求。

以上涵盖了Nacos Config 推送模型的核心特性，包括其对于高并发处理的优化，以及如何通过长轮询机制平衡服务端负载和配置更新的即时性。

### Nacos Config 的拉模式

Nacos Config 客户端使用的是拉（pull）模式来获取配置文件。当应用启动或者运行时，Nacos 客户端会定期向 Nacos 服务器发送请求以检查配置的更新。如果检测到配置有更新，客户端会拉取最新的配置信息并应用到应用程序中。

这种模式的工作流程通常如下：

1. **启动时拉取**: 应用启动时，Nacos 客户端会首先从配置中心拉取配置信息，并初始化应用程序的配置。
2. **运行时监听**: 应用运行过程中，客户端会定期（或通过长轮询机制）向 Nacos 服务器发送请求，以检查配置是否有更新。
3. **配置更新**: 如果发现配置有更新，Nacos 客户端会从服务器拉取最新的配置信息，并根据客户端配置的刷新机制更新应用程序的配置。

这种拉取模式的优点是简单且容易控制，但缺点是客户端可能不会立即获得配置更新，而是在下一个检查周期才会应用新的配置。 若要实现更快的配置更新，可以配置较短的轮询间隔，但这会增加对Nacos服务器的请求负载。

Nacos 也提供了一些机制来优化这一过程，比如支持配置的变化监听，这样客户端可以在配置变更时立即知晓，并不需要等待下一个轮询周期。这通常是通过长轮询来实现的，服务端会在配置发生变化时立即通知客户端。

### 1.x通信模型存在的问题

#### 心跳数量多，导致TPS居高不下

通过心跳续约，当服务规模上升时，特别是类似Dubbo的接口级服务较多时，心跳及配置元数据的轮询数量众多，导致集群TPS很高，系统资源高度空耗。

#### 通过心跳续约感知服务变化，时延长

心跳续约需要达到超时时间才会移除并通知订阅者，默认为15s，时延较长，时效性差。若改短超时时间，当网络抖动时，会频繁触发变更推送，对客户端服务端都有更大损耗。

#### UDP推送不可靠，导致QPS居高不下

由于UDP不可靠，因此客户端测需要每隔一段时间进行对账查询，保证客户端缓存的服务列表的状态正确，当订阅客户端规模上升时，集群QPS很高，但大多数服务列表其实不会频繁改变，造成无效查询，从而存在资源空耗。

#### 基于HTTP短连接模型，TIME_WAIT状态连接过多

HTTP短连接模型，每次客户端请求都会创建和销毁TCP链接，TCP协议销毁的链接状态是WAIT_TIME，完全释放还需要一定时间，当TPS和QPS较高时，服务端和客户端可能有大量的WAIT_TIME状态链接，从而会导致connect time out错误或者Cannot assign requested address 的问题。

#### 配置模块的30秒长轮询引起的频繁GC

配置模块使用HTTP短连接阻塞模型来模拟长连接通信，但是由于并非真实的长连接模型，因此每30秒需要进行一次请求和数据的上下文切换，每一次切换都有引起造成一次内存浪费，从而导致服务端频繁GC。

------

# Nacos2.x的通信架构

![img](https://cdn.nlark.com/yuque/0/2022/png/22792614/1658677362256-0951988e-8bb3-442f-a832-feff91005e7f.png)

## 通信模型

Nacos 2.x版本引入了一个新的通信模型，主要是为了更好地支持大规模服务的场景和提高系统的性能。在Nacos 1.x版本中，配置管理和服务发现主要是通过HTTP RESTful API来完成的，适用于小到中等规模的服务集群。然而，随着服务规模的增长，HTTP模式在处理大量服务实例和配置变更时，其性能和可扩展性可能会成为瓶颈。

Nacos 2.x版本采用了一种新的基于gRPC的通信模型，以应对大规模服务场景。gRPC是一个高性能、跨语言的RPC框架，它使用HTTP/2作为传输协议，支持多路复用、服务器推送以及其他一些提高网络通信效率的特性。

### Nacos 2.x通信模型的关键特点：

1. **基于gRPC的长连接**：Nacos 2.x使用gRPC建立与客户端之间的长连接，这样可以减少因频繁建立和关闭连接所带来的额外开销。长连接能够高效地处理请求和推送消息，尤其是在服务实例状态变化频繁的情况下。

2. **服务端推送**：与基于HTTP的轮询模型不同，gRPC支持服务端推送，这意味着服务端可以主动推送更新到客户端，而不需要客户端周期性地发送请求来检查更新。这可以大大减少响应时间，并降低网络和CPU的消耗。

3. **多路复用**：HTTP/2支持多路复用，这允许在单个连接上同时发送多个请求和响应，而不需要等待前一个传输完成。这提高了连接的利用率，并降低了延迟。

4. **支持服务和配置管理**：Nacos 2.x在同一个通信模型下支持服务发现和动态配置服务，使得客户端能够通过统一的方式处理配置更新和服务注册/发现。

5. **性能和可扩展性**：新的通信模型提高了Nacos的性能和可扩展性，特别是在大规模集群环境中，能够支持更多的服务实例和更频繁的配置更新。

6. **向后兼容性**：虽然Nacos 2.x引入了新的通信模型，但它仍然保持了与Nacos 1.x版本的兼容性，以便于老用户平滑升级。

Nacos 2.x的这些改进使其更加适合用于云原生和微服务架构，尤其是在Kubernetes等容器编排平台上，可以更好地支持服务发现和配置管理的需求。

### 存在的问题

基于长连接的gRPC模型在Nacos 2.x中相对于传统Tomcat HTTP短连接模型的一些潜在问题和挑战：

#### 连接状态管理

- 在HTTP短连接模型中，每次请求后连接都会关闭，所以连接的生命周期管理相对简单。
- 长连接模型中，连接会保持开启状态，这要求服务端和客户端都必须更加注意连接管理。例如，它们需要能够检测和恢复断开的连接，可能还要实现心跳机制来保持连接活跃。

#### **可观测性和易用性**

- 传统的HTTP接口（RESTful API）通常是文本格式的，可以很容易地通过浏览器或者简单的curl命令进行访问和测试，这使得它们具有很好的可观测性和易用性。
- gRPC基于HTTP/2的二进制协议实现，虽然提高了效率，但降低了可观测性。二进制协议不像文本协议那样易于阅读和调试。开发者可能需要专门的工具和知识来监视和调试gRPC流量。

#### **调试和监控**

- 相比于短连接HTTP模型，长连接模型在调试和监控方面更加复杂。开发者需要专门的工具和适配器来捕获和分析gRPC通信中的数据。
- 在微服务和分布式系统中，跟踪和监控请求流动变得尤其重要。gRPC流量的监控可能需要集成额外的追踪系统，如OpenTelemetry，来提供调用链路追踪。

#### **防火墙和中间件的兼容性**

- 一些网络设备和中间件可能没有为HTTP/2或gRPC流量优化，因此可能需要额外的配置或更新，以确保流量能够顺畅通过。

综上所述，虽然长连接和gRPC提供了性能和效率上的优势，但同时也引入了管理复杂性和可观测性方面的挑战。这要求开发和运维团队具备相关知识，并可能需要引入新的工具和实践来应对这些问题。

------

# Nacos2.x版本的部署

| 端口 | 与主端口的偏移量 | 描述                                                       |
| ---- | ---------------- | ---------------------------------------------------------- |
| 9848 | 1000             | 客户端gRPC请求服务端端口，用于客户端向服务端发起连接和请求 |
| 9849 | 1001             | 服务端gRPC请求服务端端口，用于服务间同步等                 |
