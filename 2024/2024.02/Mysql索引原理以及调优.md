# [MySQL为什么使用索引](https://blog.csdn.net/likunxing/article/details/135117047)

索引是帮助MySQL高效获取数据的**排好序的数据结构**。

空间换时间。

# MySQL数据结构详解

## Hash

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2542e12ea05c48efb14b2e8d603cc99c.png)

### 存储引擎 MEMORY

### [数据结构](https://www.jianshu.com/p/732a16af1f8d)

- keys：创建索引的列值；
- buckets：计算出来的hash值和对应的数据的物理位置组成的hash表；
- entries：具体的数据行；

### 特点和性能

#### 自适应哈希索引

- 如果InnoDB检测到某些索引键值被频繁查询，它会自动在内存中为这些键值创建哈希索引。

- 动态构建：根据数据访问模式自动创建，无需人工干预。
- 基于频繁访问：针对频繁查询的索引键构建哈希索引。
- 快速定位：使用哈希函数快速定位到B+树索引中的页。
- 等值查询优化：主要改善等值查询性能，对范围查询无效。
- 冲突解决：通过链表解决哈希冲突。
- 自动管理：完全由InnoDB引擎内部管理，无需DBA手动配置。

#### 时间复杂度

理想情况下，哈希表的查找、插入和删除操作的时间复杂度都是<u>O(1)</u>。但在最坏的情况下（哈希冲突例如所有键都映射到同一个位置），这些操作的时间复杂度会上升<u>至O(n)</u>。

#### 动态调整大小

动态调整哈希表大小的步骤通常包括：

1. **检测**：在每次插入或删除操作后，检查当前的**加载因子**是否仍然在预定的阈值范围内。
2. **扩容或缩容**：如果加载因子超出阈值，进行调整。扩容通常是将槽位数量加倍，而缩容则是减半。
3. **重新哈希**：创建一个新的哈希表，并使用新的大小。遍历旧的哈希表中的所有条目，并将它们插入到新的哈希表中。这个过程需要重新计算每个条目的哈希值，因为槽位的数量已经改变。
4. **替换**：用新的哈希表替换旧的哈希表，完成大小调整。在哈希表的重新哈希过程中（第4步替换），实际上并没有在新旧哈希表间建立槽位的直接映射关系。

#### 为什么不适合做Mysql索引

- **不支持顺序访问和范围查询**： 哈希表提供了非常高效的点查询（基于精确键值的查找），但对于数据库中常见的范围查询（如查找所有在某个范围内的记录）则无能为力。

- **磁盘I/O效率**： 哈希表的数据存储不是顺序的，这不利于磁盘上顺序存储的数据读取，可能导致频繁的磁盘I/O操作。

- **冲突处理问题**： 在大规模数据环境中，冲突处理可能会成为一个问题，尤其是当哈希表的负载因子变得很高时。

- **数据局部性差**： 哈希表不具备良好的数据局部性，这在基于磁盘的存储系统中可能导致性能问题。数据局部性是指在一段时间内，程序倾向于重复访问相同的数据集或者相关数据集的现象。

  ------

  

## 二叉树

### 数据结构

定义规则为左边节点值比根节点小，右边节点值比根节点大，并且左右子节点都是排序树。可能退化成链表的形式。

### 特点和性能

#### 时间复杂度

在平衡的情况下，查找/插入/删除 操作的时间复杂度是O(log n)，因为每次查找都会排除掉一半的可能节点。

退化成链表的时候，时间复杂度降为O(n)。

### 为什么不适合做Mysql索引

- 容易失衡： 普通的二叉树在连续的插入和删除操作后容易失去平衡，导致性能急剧下降

- 磁盘I/O效率： 数据库通常存储在磁盘上，二叉树的结构并不利于磁盘上的数据读取。在数据库中，减少磁盘读取次数是优化查询的关键
- 内存使用： 二叉树每个节点只有两个子节点链接，这在大型数据库中可能导致内存使用不够高效

------



## 红黑树

### 数据结构

树的高度在大数据量的情况下会很高。

红黑树是一种自平衡的二叉搜索树，它通过在每个节点上维护一个额外的颜色属性（红色或黑色）来确保树大致平衡。在红黑树中，颜色是用来帮助维持树的平衡的一种工具，而且这种颜色属性是具有实际意义的。颜色的使用遵循几个重要的性质，它们确保操作（如插入和删除）可以在对数时间内完成，这些性质包括：

1. **节点颜色**：每个节点都被涂成红色或黑色。
2. **根属性**：树的根节点是黑色的。
3. **红色节点的子节点**：如果一个节点是红色的，则它的子节点必须是黑色的（也就是说，不能有两个相邻的红色节点）。
4. **黑色高度的一致性**：从任何给定的节点到其任何叶子节点的所有路径都包含相同数量的黑色节点。
5. **叶子节点的颜色**：所有叶子节点（通常是指空（NIL）节点）都是黑色的。

这些规则共同作用，以确保最长的可能路径（从根节点到最远的叶子节点的路径，它必然包括红色和黑色节点）不会超过最短的可能路径（从根节点到最近的叶子节点的路径，它只包括黑色节点）的两倍长度。这种情况最大化了搜索操作的效率。

红黑树的关键优势在于重新平衡的操作（如旋转和重新着色）在插入和删除节点时都是局部化的，并且时间复杂度可以保持在O(log n)，其中n是树中节点的数量。

红色节点的引入允许红黑树在临时违反二叉搜索树的完全平衡性，以便于执行快速的插入和删除操作。之后通过一系列的颜色变化和局部旋转，树可以在不牺牲操作效率的前提下，迅速恢复平衡。

这种颜色编码方法的关键在于它提供了一种简单而有效的方式来保持树的平衡，这对于维护高效的搜索、插入和删除操作至关重要。

### 特点和性能

- 自平衡结构： 红黑树通过旋转和重新着色节点来维持树的平衡
- 时间复杂度： 查找、插入、删除操作的时间复杂度都是O(log n)，即使在最坏情况下也是如此
- 操作复杂性： 维持树的平衡需要额外的逻辑，这使得红黑树的操作比普通二叉树更为复杂

### 为什么不适合做Mysql索引

- 维护成本： 尽管红黑树提供了自平衡机制，但维持这种平衡的成本相对较高，特别是在数据库这样频繁插入和删除的环境中
- 磁盘I/O效率： 红黑树并没有专门为减少磁盘I/O设计。数据库系统中，减少磁盘读写是优化查询性能的关键因素
- 范围查询效率： 虽然红黑树对于点查询是高效的，但对于数据库常见的范围查询来说，并不是最优选择。范围查询可能需要遍历树的多个部分
- 内存占用： 红黑树每个节点需要额外存储颜色信息，而且由于是二叉结构，它不如多路搜索树（如B树或B+树）在内存使用上高效
- 不适合大规模数据： 对于拥有大量数据的数据库来说，红黑树的深度可能会比多路搜索树更大，这影响了查询效率。
- n个节点的红黑树的高度h![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c8ff6fc73c8246fbbb4598c88de6ad55.png)

## [btree](https://cloud.tencent.com/developer/article/1765523)

### 数据结构

多路平衡查找树也就是多叉的意思，从上图中可以看出，每个节点保存的关键字的个数和路数关系为：**关键字个数 = 路数 – 1。**

InnoDB存储引擎有页的概念，默认是16KB。

### 特点和性能

- 多路平衡查找树： B-Tree是一种自平衡的多路查找树，它的节点可以有多个子项和键。
- 磁盘I/O优化： B-Tree设计用于优化大量数据的读写操作，特别是在磁盘存储的情况下。它通过减少树的高度来减少磁盘访问次数。
- 时间复杂度： 查找、插入和删除操作的平均和最坏情况时间复杂度都是O(log n)
- 节点利用率： B-Tree节点通常被填充到其最大子节点数的一定比例，这样可以保证树的平衡并且减少空间的浪费。

### 为什么不适合做Mysql索引

- 范围查询效率： 虽然B树对范围查询有一定的支持，但它在进行这类操作时的效率仍然不如B+Tree。在B-Tree中，数据和键分布在整个树中，这使得执行范围查询需要遍历多个节点。
- 非叶节点的存储和访问： 在B-Tree中，非叶节点存储了键和数据，这导致对这些节点的访问和修改后达到自平衡机制可能会引起性能问题，尤其是在树的上层。
- 树的高度相对过高： 我们做一个推算：
  InnoDB存储引擎中页的大小为16KB，我们假设一条数据的大小为1KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为6个字节，也就是说根节点一个页中大概存储16KB/(8B+6B+1KB)≈16条数据，也就是说一个高度为3的B-Tree索引可以维护16 * 16 * 16 = 4096条记录。当Mysql数据个数为100万时，数的高度为5，虽然相比于红黑树已经很好了，但是相比于B+Tree还是差点气候。

## btree+

MySQL选择使用B+Tree索引而不是纯粹的BTree索引主要基于以下优势：

1. **更大的分支因子**：B+Tree的内部节点不存放数据，只存放键值，因此相比BTree，B+Tree的内部节点可以存放更多的键。这意味着B+Tree可以有更宽的宽度，从而减少树的高度。低树高意味着查询时需要的磁盘I/O次数更少，因为从根节点到叶子节点的路径更短。
2. **高效的范围查询**：B+Tree的叶子节点包含了所有的键值，并且叶子节点之间是相互链接的。这使得对键值的范围查询非常高效，因为一旦找到范围的起始点，接下来的键值可以通过遍历叶子节点的链表顺序读取，而不需要回溯到内部节点。
3. **I/O优化与预读性能**：由于B+Tree的结构，数据库系统可以更有效地预读叶子节点。磁盘预读（sequential read）通常比随机读取（random access）快很多，因为磁盘的旋转和寻道时间会大大增加随机读取的延迟。B+Tree索引可以将范围查询转换成顺序读取操作，从而提高查询效率。
4. **稳定的查询性能**：在B+Tree中，所有的查找操作都会到达叶子层，因此每次搜索的磁盘I/O次数相对稳定。而在BTree中，数据可以存储在任何一个节点上，这可能导致不同的搜索路径长度不一致，查询性能不稳定。
5. **全键值扫描优化**：在B+Tree中，因为所有的键值都在叶子节点上并且是顺序存储的，所以进行全表扫描（Full Table Scan）时，只需顺序读取叶子节点即可。在BTree中，这样的操作需要遍历所有的节点，包括内部节点和叶子节点，效率较低。

综合以上因素，B+Tree索引在数据库中用于索引的场景中提供了更优的读取性能，尤其是在需要频繁进行查找和范围查询的环境中。这些特点使得B+Tree成为了MySQL等关系型数据库中索引的理想选择。

针对B+Tree的高度我们做一个推算：

InnoDB存储引擎中页的大小为16KB，我们假设一条数据的大小为1KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），我们这里使用BIGINT来计算，指针类型也一般为6个字节，也就是说非叶子节点一个页中大概存储16KB/(8B+6B)=1170个键值，而叶子节点的一个页（因为InnoDB存储引擎叶子节点还要存储数据）大概存储16KB/(8B+6B+1KB)≈16条数据。也就是说一个高度为3的B+Tree索引树可以维护1170 * 1170 * 16 = 2000多万条记录。高度为4的B+Tree索引树可以维护1170 * 1170 * 1170 * 16 = 200多亿条记录。

## 总结

数据库索引的设计核心是提高数据检索的效率，同时尽量减少存储空间的占用。 这通常涉及到磁盘I/O操作的优化，因为磁盘访问（尤其是机械硬盘）比内存和CPU处理要慢得多。磁盘的两个主要机械动作——盘片旋转和磁臂移动，决定了数据访问的速度。因此，索引结构应该尽量减少访问磁盘的次数，以提高整体性能

在数据库索引的选择中，B+Tree因其在磁盘I/O优化、范围查询效率和空间利用率方面的优势而成为首选。红黑树和哈希表虽然在特定情境下性能优异，但不完全适合数据库索引的需求。B-Tree虽然是一个不错的选择，但在数据库索引的应用上，它的某些特性（如范围查询效率）不如B+Tree。而普通的二叉树由于容易失衡，不适合用于处理大量数据的数据库索引。

# 聚集索引和非聚集索引