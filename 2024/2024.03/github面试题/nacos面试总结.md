---
Nacos是一个开源的服务发现和配置管理系统。它的主要功能包括服务注册与发现、动态配置管理、服务健康监测等。

Nacos架构分为1.X和2.0两个版本。1.X版本分为接入层、通信层、功能层、同步层和持久化层。2.0版本引入了gRPC和Rsocket实现长连接通信,提高了性能和可靠性。

Nacos在CAP理论中支持AP和CP模式,默认是AP。客户端注册时ephemeral=true则是AP模式,ephemeral=false则是CP模式。

Nacos区分临时节点和永久节点。临时节点用于动态服务注册与发现,与服务实例生命周期绑定。永久节点用于存储静态配置信息。

Nacos提供保护阈值功能,防止健康实例被流量冲垮。可通过配置文件设置阈值。

Nacos提供服务端的负载均衡,在服务发现时可按照策略只返回部分实例。

Nacos的就近访问是指优先访问同一集群(cluster-name相同)的服务实例。

Nacos通过CopyOnWrite避免实例信息读写冲突。

Spring Boot服务可通过引入依赖、配置Nacos地址,并在启动类上添加@EnableDiscoveryClient注解来集成Nacos。

在Nacos中可进行动态配置管理。通过在控制台发布配置,并在代码中以@Value注入使用。结合@RefreshScope可实现配置热更新。
---

## 什么是`nacos`？`nacos`有什么作用？

`nacos`是一个开源的分布式服务发现和配置管理系统,它的主要作用是服务注册、发现和配置管理。

> `Nacos`的主要功能和作用包括：
>
> 1. **服务发现与注册**：`Nacos`可以用于服务的注册和发现，使微服务架构中的各个服务能够相互发现和调用，从而实现服务之间的协作和通信。服务提供者在启动时将自己注册到`Nacos`服务器，服务消费者可以从`Nacos`服务器获取服务提供者的地址。#Spring Boot微服务向Nacos注册
> 2. **动态配置管理**：`Nacos`提供了一个集中式的配置管理功能，允许开发人员动态管理应用程序的配置。配置可以存储在`Nacos`服务器上，并且可以根据需要在运行时动态刷新，无需重启应用程序。这有助于实现敏捷的配置管理和快速的配置变更。
> 3. **服务健康监测**：`Nacos`可以监测注册的服务的健康状态，如果服务不可用或出现问题，`Nacos`可以通知其他服务或自动进行实例剔除，以确保系统的可用性。
> 4. **动态路由配置**：`Nacos`支持动态配置路由规则，可以用于实现服务的动态路由，例如灰度发布、AB测试等。
> 5. **多数据中心支持**：`Nacos`具备多数据中心的支持，这意味着你可以在不同的地理位置部署`Nacos`服务器，并跨数据中心注册和发现服务。
> 6. **事件监听和通知**：`Nacos`支持事件监听和通知机制，当服务的状态或配置发生变化时，可以通知相关的应用程序，从而实现自动化的反应和处理。

## `Nacos`架构

### `Nacos` 1.X 架构层次

![1.x架构.jpeg](https://gitlab.com/Echo-xzp/Resource/-/raw/main/img/2023/09/6_21_42_34_a40410451cf34cee8a62e9aeed187241.jpeg)

#### 具体描述：

`Nacos` 1.X 大致分为 5 层， 分别是接入、通信、功能、同步和持久化。

**接入层**是用户最直接交互的层面，主要有 `Nacos` 客户端，以及依赖客户端的 Dubbo 和 SCA 以及用户操作的控制台 Console 组成。客户端和 Console 进行服务和配置操作，统一通过 HTTP 的 `OpenAPI` 发起通信请求。

**通信层**主要基于 HTTP 的短连接请求模型进行，部分推送功能通过 UDP 进行通信。

**功能**目前有服务发现和配置管理，这层也就是实际管理服务和配置的业务层。

**同步层**有数据同步的 AP 模式 Distro 和 CP 模式 Raft，还有有一个最简易的水平通知 Notify，用处各不相同：

- Distro：非持久化服务的同步模式。
- Raft：持久化服务的同步模式、以及使用 Derby 作为配置的存储时同步配置操作。
- Notify：使用 MySQL 作为配置的存储时，通知其他节点更新缓存及发起配置推送。

**持久化层** `Nacos` 使用 MySQL、Derby 和本地文件系统来进行数据的持久化 配置信息，用户信息，权限信息存储在 MySQL 或 Derby 数据库中， 持久化服务信息及服务和实例元数据信息存储在本地文件系统。

#### 存在问题：

- **心跳数量多，导致 TPS 居高不下**

> 通过心跳续约，当服务规模上升时，特别是类似 Dubbo 的接口级服务较多时，心跳及配置元数据的轮询数量众多，导致集群 TPS 很高，系统资源高度空耗。

- **通过心跳续约感知服务变化，时延长**

> 心跳续约需要达到超时时间才会移除并通知订阅者，默认为 15s，时延较长，时效性差。若改短超时时间，当网络抖动时，会频繁触发变更推送，对客户端服务端都有更大损耗。

- **UDP 推送不可靠，导致 QPS 居高不下**

> 由于 UDP 不可靠，因此客户端测需要每隔一段时间进行对账查询，保证客户端缓存的服务列表的状态正确，当订阅客户端规模上升时，集群 QPS 很高，但大多数服务列表其实不会频繁改变，造成无效查询，从而存在资源空耗。

- **基于 HTTP 短连接模型，TIME_WAIT 状态连接过多**

> HTTP 短连接模型，每次客户端请求都会创建和销毁 TCP 链接，TCP 协议销毁的链接状态是 WAIT_TIME，完全释放还需要一定时间，当 TPS 和 QPS 较高时，服务端和客户端可能有大量的 WAIT_TIME 状态链接，从而会导致 connect time out 错误或者 Cannot assign requested address 的问题。

- **配置模块的 30 秒长轮询引起的频繁 GC**

> 配置模块使用 HTTP 短连接阻塞模型来模拟长连接通信，但是由于并非真实的长连接模型，因此每 30 秒需要进行一次请求和数据的上下文切换，每一次切换都有引起造成一次内存浪费，从而导致服务端频繁 GC。

#### 项目版本

顺电的项目版本是1.4.2

### 	`Nacos`  2.0 架构层次

![7.jpeg](https://gitlab.com/Echo-xzp/Resource/-/raw/main/img/2023/09/6_21_48_10_8e4ccf764e4843789571322bbef06eb9.jpeg)

#### 具体描述:

通信层目前通过 `gRPC` 和 `Rsocket` 实现了长连接 RPC 调用和推送能力。

在服务端测，新增一个链接层，用来将不同类型的 Request 请求，将来自不同客户端的不同类型请求，转化为相同语意的功能数据结构，复用业务处理逻辑。同时，将来的流量控制和负载均衡等功能也会在链接层处理。

其他架构分层在大体上保持不变。

#### 优点

- 客户端不再需要定时发送实例心跳，只需要有一个维持连接可用 keepalive 消息即可。重复 TPS 可以大幅降低。
- TCP 连接断开可以被快速感知到，提升反应速度。
- 长连接的流式推送，比 UDP 更加可靠；nio 的机制具有更高的吞吐量，而且由于可靠推送，可以加长客户端用于对账服务列表的时间，甚至删除相关的请求。重复的无效 QPS 可以大幅降低。
- 长连接避免频繁连接开销，可以大幅缓解 TIME_ WAIT 问题。
- 真实的长连接，解决配置模块 GC 问题。
- 更细粒度的同步内容，减少服务节点间的通信压力。

#### 缺点

没有银弹的方案，新架构也会引入一些新问题：

- 内部结构复杂度上升，管理连接状态，连接的负载均衡需要管理。
- 数据又原来的无状态，变为与连接绑定的有状态数据，流程链路更长。
- RPC 协议的观测性不如 HTTP。即使 gRPC 基于 HTTP2.0Stream 实现，仍然不如直接使用 HTTP 协议来的直观。

# 阐述Nacos 1.4.2和2.0版本的区别

## 通信方式的改进

- Nacos 1.4.2版本主要基于HTTP短连接进行通信,存在心跳频繁、时延较高、UDP推送不可靠等问题。而Nacos 2.0版本引入了基于gRPC和Rsocket的长连接通信模型,显著减少了心跳频率,提高了感知服务变化的实时性,并通过可靠的TCP协议替代了UDP推送。
- ```markdown
  当服务实例注册到Nacos服务端后,客户端会启动一个定时任务,每隔一定时间向服务端发送一次心跳请求。
  
  默认情况下,这个时间间隔是5秒,也就是每5秒发送一次心跳。
  
  服务端接收到心跳请求后,会更新对应服务实例的最后心跳时间。如果在一定时间内(默认为15秒)没有收到心跳,服务端就会认为该服务实例不健康。
  ```
- 面试官可能会问:Nacos 1.4.2的通信模型有哪些缺陷?Nacos 2.0是如何优化的?你在项目中如何权衡短连接和长连接?

## 性能和可靠性提升

- 得益于长连接通信模型,Nacos 2.0版本相比1.4.2版本,在TPS、QPS等性能指标上有显著提升。长连接避免了频繁的连接开销,缓解了TIME_WAIT问题。同时,可靠的TCP推送替代了UDP,降低了无效的重复查询。
- 面试官可能会问:Nacos 2.0在性能和可靠性方面有哪些提升?这些提升的原理是什么?在你的项目中,Nacos的性能表现如何?

## 配置管理的优化

- Nacos 1.4.2版本的配置管理采用长轮询模式,实际上是通过短连接实现,每30秒一次请求,频繁的GC会影响性能。Nacos 2.0采用真正的长连接,避免了这一问题。
- 面试官可能会问:Nacos 1.4.2的配置管理有什么缺陷?Nacos 2.0是如何优化的?在你的项目中,配置变更的实时性和可靠性如何保证?

## 领域模型的变化

- Nacos 2.0调整了部分领域模型,如更细粒度的服务发现数据,减少了节点间的数据同步量。但这也带来了一些复杂性,如有状态的连接管理。
- 面试官可能会问:Nacos 2.0对领域模型做了哪些调整?这些调整的利弊是什么?在数据一致性和性能之间,你是如何权衡的?

## 生态适配与迁移

- Nacos 2.0提供了与1.x版本的兼容性,但一些底层通信机制的变化,可能需要业务代码或框架的适配。服务端与客户端需要协调升级,需要一定的迁移成本。
- 面试官可能会问:从Nacos 1.4.2迁移到2.0,需要注意哪些问题?你如何评估和管理迁移的风险?在项目中,你是如何平滑完成Nacos版本升级的?

以上就是我从面试的角度,对Nacos 1.4.2和2.0版本差异的一些阐述。作为候选人,需要展示对Nacos架构演进的深入理解,并结合自己的项目经验,说明如何评估和应对版本升级带来的挑战。同时也要展现技术选型和权衡的思路,体现全局观和系统思维。

## 什么是CAP理论，`nacos`是CP还是AP？

CAP理论的三个属性解释如下：

> 1. **一致性（Consistency）**：在分布式系统中，一致性表示在任何时刻，所有节点对于同一份数据的访问都会返回相同的数据值。这意味着无论客户端向系统的哪个节点发出请求，它们都应该得到相同的答案。一致性要求分布式系统在数据更新后立即反映出这些变更，这可能需要牺牲部分可用性。
> 2. **可用性（Availability）**：可用性表示分布式系统在有限时间内能够对客户端的请求做出响应，即系统保持运行，不会因为节点的故障或其他问题而停止响应请求。可用性要求分布式系统在出现故障时仍然能够提供服务，即使是部分服务。
> 3. **分区容忍性（Partition Tolerance）**：分区容忍性表示分布式系统在面临网络分区（节点之间的通信断开或延迟）的情况下仍然能够正常运行。分布式系统通常需要跨越多个网络节点，因此网络分区可能是不可避免的，分区容忍性要求系统在分区发生时能够继续工作。
>
> `nacos`支持AP(可用性 | 分区容错性) 和 CP(一致性 | 分区容错性)两种  默认是AP
>
> 如果注册`Nacos`的client节点注册时 **ephemeral=true**(临时节点/永久节点)，那么`Nacos`集群对这个client节点的效果就是AP，采用distro协议实现；而注册`Nacos`的client节点注册时ephemeral=false，那么`Nacos`集群对这个节点的效果就是CP的，采用raft协议实现。根据client注册时的属性，AP，CP同时混合存在，只是对不同的client节点效果不同。`Nacos`可以很好的解决不同场景的业务需求。

### Nacos怎么实践CAP理论

#### 服务注册与发现

- 对于临时实例(ephemeral=true),Nacos采用AP模式。这意味着在出现网络分区时,Nacos会优先保证服务的可用性,允许不同节点的数据存在一定的不一致性。这适用于对可用性要求较高,而对数据一致性要求相对宽松的场景,如微服务的服务发现。
- 对于持久化实例(ephemeral=false),Nacos采用CP模式。这意味着在出现网络分区时,Nacos会优先保证数据的一致性,即使这可能导致部分服务暂时不可用。这适用于对数据一致性要求较高的场景,如配置管理。
- Nacos通过Distro协议实现AP模式,通过Raft协议实现CP模式。用户可以根据业务需求,灵活选择不同的一致性模型。

#### 配置管理

- 在使用MySQL作为配置存储时,Nacos采用CP模式。这是因为配置数据通常需要强一致性,且修改频率相对较低。使用MySQL可以保证配置在各节点间的一致性。
- 在使用本地文件作为配置存储时,Nacos采用AP模式。这是因为文件存储无法提供强一致性保证,但可以提供较高的可用性。这种模式适用于对一致性要求相对宽松的场景。

## `Nacos`为什么要区分临时节点和永久节点?

`Nacos`之所以区分临时节点和永久节点，是因为这两种节点具有不同的生命周期和用途，以满足不同场景下的需求。这种区分是为了提供更灵活的服务注册与发现以及配置管理功能。以下是临时节点和永久节点的主要区别和用途：

1. **临时节点（Ephemeral Nodes）**：
   
   - **生命周期短暂**：临时节点的生命周期与服务实例的生命周期相对应。当一个服务实例注册一个临时节点时，它会在Nacos服务器上保持活动状态，只要该服务实例保持运行，节点就存在。一旦服务实例终止或主动注销，节点将被自动删除。
   
   - **适用于动态服务**：临时节点通常用于表示动态的、可能经常启动和关闭的服务实例。这对于微服务架构中的服务注册与发现非常有用，因为它们能够自动反映服务实例的状态。

2. **永久节点（Persistent Nodes）**：

   - **持久存在**：永久节点在注册后将一直存在，直到显式删除。它们不会因为服务实例的终止而被自动删除，只会将健康状态标记为不健康，只有在进行手动删除操作时才会被移除。
   
   - **适用于静态配置**：永久节点通常用于存储静态配置信息或全局的服务信息，这些信息不会频繁改变。例如，全局配置、共享资源、重要的服务信息等可以存储在永久节点中，以供各个服务实例访问。

通过区分临时节点和永久节点，Nacos可以适应不同的应用场景。临时节点使得服务实例能够动态注册和注销，从而实现高度动态的服务发现。永久节点则用于存储静态的配置和全局信息，以供所有服务实例访问，确保这些信息在整个系统中保持一致。

这种区分还有助于提高系统的可伸缩性和性能，因为`Nacos`可以更有效地管理临时节点，而不必关心永久节点的生命周期。这有助于优化服务注册与发现的性能和资源利用率。

## `Nacos`中的保护阈值的作用是什么？

假如现在有一个服务，本来有10个实例，但是现在挂掉了8个，剩下2个正常实例，此时本来由10个实例处理的流量，就全部交给这个两个正常实例来处理了，此时这两个实例很有可能是处理不过来的，最终导致被压垮，为了应对这种情况，`Nacos`提供了保护阈值这个功能，我们可以给某个服务设置一个0-1的阈值，比如0.5，那就表示，一旦实例中只剩下一半的健康实例了，比如10个实例，只剩下5个健康实例了，那么消费者在进行服务发现时，则会把该服务的所有实例，也包括不健康的实例都拉取到本地，然后再从所有实例中进行负载均衡，选出一个实例进行调用，在这种情况下，选出来的即可能是一个健康的实例，也可能是挂掉的实例，但是通过这种方式，很好的保护的剩下的健康实例，至少保证了一部分请求能正常的访问，而不至于所有请求都不能正常访问，这就是`Nacos`中的保护阈值，同时，这个功能在Spring Cloud Tencent中叫全死全活。

### 保护阈值怎么设置

在`Nacos`中,保护阈值的配置是通过服务端的配置文件来实现的。具体的配置位置和方式如下:

#### `Nacos`服务端配置文件

- 打开`Nacos`服务端的配置文件,一般是`application.properties`或`application.yml`
- 默认情况下,配置文件位于`Nacos`安装目录下的`conf`目录中

#### 设置保护阈值参数

- 在配置文件中,找到以下参数:

  复制

  ```
  nacos.naming.distro.protected.threshold=0.5
  ```

- 其中,`nacos.naming.distro.protected.threshold`表示保护阈值参数

- 默认值为0.5,表示当服务实例的心跳丢失比例超过50%时,`Nacos`会将实例剔除

- 可以根据需要调整该参数的值,范围是0到1之间的浮点数

#### 重启`Nacos`服务端

- 修改配置文件后,需要重启`Nacos`服务端才能生效

- 可以通过以下命令重启Nacos服务端:

  ```
  sh startup.sh -m standalone
  ```

- 其中,`-m standalone`表示以单机模式启动`Nacos`服务端

#### 验证保护阈值配置

- 重启nacos服务端后,可以通过以下方式验证保护阈值配置是否生效:
- 访问`Nacos`的控制台页面,默认地址是`http://localhost:8848/nacos`
- 在控制台中查看服务列表,如果服务实例的心跳丢失比例超过保护阈值,实例状态会显示为"不健康"
- 也可以通过`Nacos`的`API`接口,如`/nacos/v1/ns/instance/list`接口,来查询服务实例的状态

需要注意的是,保护阈值的配置是全局生效的,即所有的服务实例都会受到该参数的影响。如果需要对不同的服务设置不同的保护阈值,可以考虑使用`Nacos`的服务级别配置或者客户端配置来实现。

另外,在生产环境中,建议通过`Nacos`的集群部署来提高服务的可用性和稳定性。可以将`Nacos`服务端部署为多个节点,通过负载均衡和故障转移来实现高可用。这样即使个别`Nacos`节点出现故障,也不会影响整个服务的注册和发现功能。

总之,保护阈值的配置需要根据服务的实际情况和需求来权衡和调整。通过合理的配置和监控,可以有效地提高服务的可用性和稳定性,同时也能降低因为实例异常而导致的服务中断风险。

## `Nacos`中的负载均衡是怎么样的？

`Nacos`的负载均衡指的是，在进行服务发现时进行负载均衡，正常情况下，在进行服务发现时，会根据服务名从`Nacos`中拉取所有的实例信息，但是`Nacos`中提供了一个功能，就是可以在拉取实例时，可以根据随机策略只拉取到所有实例中的某一个，这就是`Nacos`中的负载均衡，它跟`Ribbon`的负载均衡并不冲突，可以理解为`Ribbon`的负载均衡是发生在`Nacos`的负载均衡之后的。

## `Nacos`的就近访问是什么意思？

首先，在`Nacos`中，一个服务可以有多个实例，并且可以给实例设置cluster-name，就是可以再进一步的给所有实例划分集群，那如果现在某个服务A想要调用服务B，那么`Naocs`会看调用服务A的实例是属于哪个集群的，并且调用服务B时，那就会调用同样集群下的服务B实例，根据`cluster-name`来判断两个实例是不是同一个集群，这就是`Nacos`的就近访问。

## `Nacos`如何避免并发读写冲突问题？

`Nacos`在更新实例列表时，会采用`CopyOnWrite`（写时复制）技术，首先将旧的实例列表拷贝一份，然后更新拷贝的实例列表，再用更新后的实例列表来覆盖旧的实例列表。

这样在更新的过程中，就不会对读实例列表的请求产生影响，也不会出现脏读问题了。

# Spring Boot微服务向Nacos注册

## 确保应用依赖spring-cloud-starter-alibaba-nacos-discovery

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
  <groupId>com.alibaba.cloud</groupId>
  <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

## 配置Nacos地址

```properties
spring:
  profiles:
    active: dev
  application:
    name: cto-framework-standard-web
  cloud:
    nacos:
      config:
        server-addr: ${spring.cloud.nacos.server-addr}
        username: nacos
        password: sundanadmin0700.^
        namespace: 3944c638-5540-41e9-a69c-96e5396b62ce
        file-extension: yaml
        refresh-enabled: true
       #服务发现
      discovery:
        server-addr: ${spring.cloud.nacos.server-addr}
        username: nacos
        password: sundanadmin0700.^
        namespace: 3944c638-5540-41e9-a69c-96e5396b62ce
      server-addr: 192.168.87.200:8848
```

## 在入口类或者配置类上增加@EnableDiscoveryClient启用Nacos客户端

```java
package com.itlaoqi.firstmicroservice.nacosdiscovery;

import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.context.annotation.Configuration;

@EnableDiscoveryClient
@Configuration
public class NacosDiscoveryConfiguration {
}

```

# `Nacos`中进行动态配置管理

## 在`Nacos`控制台中创建配置文件

- 登录`Nacos`控制台(默认地址为`http://localhost:8848/nacos`)
- 在左侧菜单中选择"配置管理" -> "配置列表"
- 点击"+"按钮,创建一个新的配置文件
- 填写配置文件的基本信息,如数据集ID、配置格式、配置内容等
- 点击"发布"按钮,将配置文件发布到`Nacos`服务器

## 在项目中引入`Nacos Config`依赖

在项目的`pom.xml`文件中添加`Nacos Config`的依赖:

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

## 配置`Nacos Config`

在项目的`application.yml`或`application.properties`文件中配置`Nacos Config`的相关信息:

## 在代码中使用配置值

在Java代码中,可以使用`@Value`注解来注入配置文件中的值:

```java
@Value("${config.key}")
private String configValue;
```

其中,`config.key`是配置文件中的键名。

## 刷新配置

当`Nacos`中的配置文件发生变更时,可以通过`@RefreshScope`注解来实现配置的自动刷新:

```java
@RestController
@RefreshScope
public class ConfigController {
    @Value("${config.key}")
    private String configValue;

    @GetMapping("/config")
    public String getConfig() {
        return configValue;
    }
}
```

在类上添加`@RefreshScope`注解,当配置文件发生变更时,Spring会自动刷新标有`@Value`注解的字段值。

通过以上步骤,就可以在项目中使用`Nacos`实现动态配置管理了。当`Nacos`中的配置文件发生变更时,项目中的配置值会自动更新,无需重启应用。

需要注意的是,`Nacos Config`的配置文件命名规则为:`${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}`。例如,如果应用名为`my-app`,激活的Profile为`dev`,配置文件后缀为`yaml`,则在`Nacos`中创建的配置文件名应为`my-app-dev.yaml`。

另外,还可以通过`spring.cloud.nacos.config.ext-config`属性来加载多个配置文件,实现配置的分类管理。

# 为什么要有配置中心？

配置中心是分布式系统中的一个重要组件，它的存在有多个关键原因和优势：

1. **集中化配置管理：** 配置中心提供了一种集中化管理应用程序配置的方式。它允许您将所有配置信息集中存储在一个地方，而不是散布在各个应用程序中。这样可以更轻松地管理配置，确保一致性和可维护性。

2. **动态配置更新：** 配置中心允许在运行时动态更新应用程序的配置，而无需重新部署或重启应用程序。这意味着您可以在不中断服务的情况下修改配置，快速适应不同的环境和需求。

3. **版本管理：** 配置中心通常支持配置版本管理，允许您跟踪和恢复以前的配置版本。这对于诊断问题、回滚配置更改以及进行审计非常有用。

4. **安全性和访问控制：** 配置中心可以提供访问控制和安全性，以确保只有授权的用户或应用程序可以访问敏感配置信息。这有助于保护敏感数据和配置。

5. **跨环境配置：** 配置中心允许为不同的环境（例如开发、测试、生产）和不同的部署场景（例如云环境、本地环境）提供不同的配置。这可以确保应用程序在不同环境中具有正确的配置。

6. **分布式应用程序支持：** 对于分布式应用程序，配置管理变得更加复杂。配置中心可以提供一种统一的方式来管理分布式系统的配置，确保不同部分的应用程序使用相同的配置信息。

7. **易于维护和变更：** 通过将配置从应用程序代码中分离出来，配置中心使得配置更容易维护和更改。开发人员可以专注于应用程序逻辑，而不必担心配置的细节。

8. **减少硬编码：** 配置中心减少了硬编码配置的需要。相反，应用程序可以从配置中心获取所需的配置信息，从而降低了代码的耦合性。

总之，配置中心的存在有助于简化配置管理、提高配置的可维护性和灵活性，支持动态更新和版本控制，同时也增强了应用程序的安全性和可管理性。对于大型和分布式系统来说，配置中心是不可或缺的工具，有助于降低维护成本并提供更好的系统可靠性和可伸缩性。

# Nacos做配置中心时是AP还是CP？

`Nacos`在作为配置中心时，通常是CP（一致性和分区容错）的系统。CP系统强调在网络分区或节点故障的情况下，保持一致性。这对于配置中心非常重要，因为配置数据的一致性是系统的关键要素，而配置变更需要被正确地传播到所有相关的服务实例中。

`Nacos`使用了Raft一致性协议来确保配置数据的一致性和可靠性。Raft是一种分布式一致性算法，能够在节点故障或网络分区的情况下保持数据的一致性。这意味着无论发生了什么故障或中断，`Nacos`都会努力保持配置数据的一致性，并确保配置更改得到正确的传播。

总之，`Nacos`作为配置中心时倾向于CP系统，它注重配置数据的一致性和可靠性，以确保系统在面对故障或分区时仍然能够提供可靠的配置管理服务。这是配置中心的关键特性，因为配置数据对于应用程序的正确运行至关重要。

# Raft和Distro有何区别？

Raft 和 Distro 是两种不同的分布式一致性协议，它们解决了不同类型的分布式系统问题，有以下区别：

**一致性问题：**

- Raft：Raft 协议主要用于解决分布式系统中的一致性问题，例如在复制日志系统中确保多个副本的一致性。Raft 强调领导者选举和日志复制，以确保数据的一致性。
- Distro：Distro（或称为Distributed Consistency Protocol）是用于解决分布式数据存储系统中的数据一致性问题的协议。它确保分布式系统中的数据副本保持一致性，以提供高可用性和容错性。

**应用领域：**
- Raft：Raft 协议通常用于分布式存储系统，如分布式数据库或分布式日志系统，以确保数据一致性和可用性。
- Distro：Distro 协议主要用于分布式数据存储系统，例如键值存储、分布式文件系统等，以确保数据一致性和高可用性。

**设计目标：**
- Raft：Raft 协议的设计目标是提供相对简单和容易理解的一致性算法，以便开发者更容易实现和维护分布式系统。
- Distro：Distro 协议的设计目标是在复杂的分布式数据存储系统中提供高一致性、高可用性和高性能的数据复制和分发。

**性能和复杂性：**
- Raft：Raft 协议相对较简单，容易理解和实现，但在一些性能和吞吐量方面可能会有一些限制。
- Distro：Distro 协议通常更复杂，因为它需要处理更多的数据分发和一致性保证，但可以提供更高的性能和可用性。

总的来说，Raft 和 Distro 都是用于分布式系统的一致性协议，但它们关注的问题领域和设计目标不同。Raft 更适合解决一致性问题，而 Distro 更适合解决分布式数据存储系统的数据一致性和高可用性问题。选择使用哪个协议取决于您的系统需求和复杂性。

# Nacos作为配置中心宕机之后，是不是意味着依赖这个配置中心的服务也读取不了配置进而下线呢？

Nacos作为配置中心宕机不会立即导致依赖该配置中心的服务下线，但它可能会对这些服务的运行产生一些影响，具体取决于服务的配置和设计。

当Nacos配置中心宕机时，可能发生以下情况：

1. **已加载的配置数据仍然可用：** 如果服务已经从Nacos配置中心加载了配置数据，并将其缓存在本地，那么即使Nacos宕机，服务仍然可以使用本地缓存的配置数据。这意味着已加载的配置在一定时间内仍然可用。

2. **新配置无法获取：** 如果服务需要获取新的配置或在Nacos宕机后尝试刷新配置，那么它将无法从Nacos获取新的配置。这可能会影响服务对于动态配置更改的感知。

3. **服务启动和注册问题：** 如果服务依赖Nacos进行服务注册和发现，Nacos宕机可能会影响新服务的注册和发现。现有的服务可能会继续运行，但新的服务可能无法注册，因为它们无法找到Nacos实例。

4. **服务的健康检查和自我修复：** 如果服务实现了自我修复机制，它们可能会尝试重新连接Nacos或在它恢复运行时重新注册自己。这取决于服务的设计和实现。

总的来说，Nacos配置中心的宕机通常不会立即导致依赖它的服务下线，但可能会对新配置的获取、服务注册和发现以及配置更新等方面产生影响。为了提高系统的可靠性，可以考虑在设计中采用适当的容错策略和缓存机制，以应对Nacos配置中心的宕机情况。此外，定期监控Nacos的健康状态并实施恢复措施也是重要的。

# 服务会主动更新已经从配置中心加载了的配置吗？

一般情况下，服务不会主动更新已经从配置中心加载的配置。服务在启动时会从配置中心加载配置数据，然后使用这些数据来配置自身的行为。一旦配置数据被加载到服务中，它通常不会自动更新。

如果您希望服务能够获取最新的配置数据并动态更新自身的行为，您需要实现配置的热加载或定期轮询配置中心以检查是否有新的配置变更。这可以通过以下方式来实现：

1. **定期轮询：** 在服务中实现一个定时任务或线程，定期向配置中心查询是否有新的配置变更。如果检测到变更，服务可以重新加载配置并应用新的配置。

2. **使用配置中心的通知机制：** 许多配置中心提供了通知机制，允许服务订阅配置变更通知。当配置发生变化时，配置中心可以通知已注册的服务。服务在接收到通知后，可以主动获取新的配置并更新自身。

3. **使用回调机制：** 部分配置中心支持回调函数，允许您在配置发生变化时执行特定的回调操作。您可以将回调函数与配置绑定，以便在配置更改时触发相应的操作。

不同的配置中心提供不同的机制来支持配置的动态更新，具体取决于您使用的配置中心的特性和功能。无论采用哪种方法，都需要确保服务能够处理配置变更，并在需要时重新加载和应用新的配置，以实现配置的动态更新。这对于实现灵活性和可维护性的分布式系统非常重要。

# 针对Nacos,如何实现动态加载配置？

Nacos可以通过以下几种方式实现动态加载配置：

1. **监听配置变更：** Nacos提供了监听配置变更的机制。您可以注册一个监听器，当配置发生变化时，Nacos将通知您的应用程序。在Java客户端中，您可以使用Nacos SDK中的`Listener`接口来实现配置监听。以下是一个简单的示例：

```java
import com.alibaba.nacos.api.config.listener.Listener;
import com.alibaba.nacos.api.config.ConfigService;

public class ConfigListenerExample {
    public static void main(String[] args) throws Exception {
        String dataId = "your-data-id";
        String group = "your-group";
        String namespace = "your-namespace";
        
        ConfigService configService = NacosFactory.createConfigService(properties);
        
        configService.addListener(dataId, group, new Listener() {
            @Override
            public void receiveConfigInfo(String configInfo) {
                // 配置发生变化时的处理逻辑
                System.out.println("Received updated config: " + configInfo);
            }
        });
        
        // 保持应用程序运行，以便继续监听配置变更
        Thread.sleep(Long.MAX_VALUE);
    }
}
```

2. **定时轮询：** 如果不使用监听机制，您还可以定期轮询Nacos以检查配置是否发生了变化。这是一种简单的方式，但效率可能较低，因为它需要定期发送请求来检查配置。

3. **使用Spring Cloud的@RefreshScope：** 如果您正在使用Spring Cloud，并且已将Nacos集成到Spring Cloud Config中，您可以使用`@RefreshScope`注解来标记需要动态刷新的bean。当配置发生变化时，通过调用Actuator的`/actuator/refresh`端点，可以刷新被`@RefreshScope`注解标记的bean。这将导致Spring重新加载配置并应用到相应的bean。

以上是几种常见的方式来实现Nacos配置的动态加载。您可以根据您的应用程序需求和技术栈选择最合适的方法。要注意，动态加载配置通常需要您的应用程序具备处理配置变更的逻辑，以确保新配置的正确应用。

# 如果此时动态加载配置，而配置中心此时是下线状态，会加载到空配置还是继续使用原来的已加载配置？

当配置中心（例如Nacos）处于下线状态时，动态加载配置的行为取决于具体的实现和配置。通常情况下，如果配置中心不可用，已加载的配置将保持不变，而不会被动态更新。

以下是不同情况下的可能行为：

1. **已加载配置的保留：** 大多数配置加载库和框架会保留已加载的配置，即使配置中心不可用。这意味着如果配置中心不可用，已加载的配置将继续被使用，而不会被替换为空配置。

2. **失败安全机制：** 一些配置加载库会实现失败安全机制，即使配置中心不可用，它们也会尝试保留已加载的配置，并在配置中心恢复可用时重新尝试获取新配置并应用。这可以提供一定程度的容错性。

3. **配置缓存：** 部分配置加载库和框架支持本地配置缓存，即使配置中心不可用，它们也可以从本地缓存中获取配置。这可以确保即使配置中心不可用，应用程序也可以继续使用缓存的配置。

请注意，上述行为可能会因使用的配置加载库或框架而有所不同。在使用特定的配置加载库时，建议查阅该库的文档，了解在配置中心不可用的情况下它的行为是如何的。

为了提高系统的可靠性，通常建议在配置中心恢复可用之前继续使用已加载的配置，以确保应用程序的正常运行。一旦配置中心再次可用，系统可以尝试获取最新的配置并动态更新。这种方式可以避免配置中心的临时故障对应用程序的影响。

# Spring Cloud中配置文件加载顺序是怎么样的？

1、开发者工具 `Devtools` 全局配置参数；

2、单元测试上的 `@TestPropertySource` 注解指定的参数；

3、单元测试上的 `@SpringBootTest` 注解指定的参数；

4、命令行指定的参数，如 `java -jar springboot.jar --name="Java技术栈"`；

5、命令行中的 `SPRING_APPLICATION_JSONJSON` 指定参数, 如 `java -Dspring.application.json='{"name":"Java技术栈"}' -jar springboot.jar`

6、`ServletConfig` 初始化参数；

7、`ServletContext` 初始化参数；

8、JNDI参数（如 `java:comp/env/spring.application.json`）；

9、Java系统参数（来源：`System.getProperties()`）；

10、操作系统环境变量参数；

11、`RandomValuePropertySource` 随机数，仅匹配：`ramdom.*`；

12、JAR包外面的配置文件参数（`application-{profile}.properties（YAML）`）

13、JAR包里面的配置文件参数（`application-{profile}.properties（YAML）`）

14、JAR包外面的配置文件参数（`application.properties（YAML）`）

15、JAR包里面的配置文件参数（`application.properties（YAML）`）

16、`@Configuration`配置文件上 `@PropertySource` 注解加载的参数；

17、默认参数（通过 `SpringApplication.setDefaultProperties` 指定）；

***在Nacos中：***

```
1. bootstrap.yaml
2. bootstrap.properties
3. bootstrap-{profile}.yaml
4. bootstrap-{profile}.properties
5. application.yaml
6. application.properties
7. application-{profile}.yaml
8. application-{profile}.properties
9. nacos配置中心共享配置（通过spring.cloud.nacos.config.shared-configs指定）
10. Nacos配置中心该服务配置（通过spring.cloud.nacos.config.prefix和spring.cloud.nacos.config.file-extension指定）
11. Nacos配置中心该服务-{profile}配置（通过spring.cloud.nacos.config.prefix和spring.cloud.nacos.config.file-extension、以及spring.profiles.active指定）

因此，配置生效覆盖关系：

对于key不同，则直接生效；

对于key相同的同名配置项，后加载会覆盖掉前加载，故而最终为后加载的配置项生效！
```

同时可以配置：

```yaml
spring:
  cloud:
    config:
      override-none: true
      allow-override: true
      override-system-properties: false  
```

开启本地配置优先

注意：**一定要在 nacos上配置不然不生效**

# 配置中心的地址不配置在`application.yaml`里面？

配置中心的地址通常是配置在`bootstrap.properties`（或`bootstrap.yml`）中的，而不是`application.properties`（或`application.yml`）中。这是因为`bootstrap`配置文件在Spring Boot应用程序启动时最先加载，它用于配置应用程序上下文之前的一些基础设置，包括与配置中心的连接信息。

比如数据库的配置配置在配置中心里面，如果把配置中心地址配置在`application.yaml`里面，当Spring加载到此处时，没有获取到注入`DataSource`所需的一些依赖，就会直接报错了。

# bootstrap和application配置文件之间有何区别？

在Spring Boot应用程序中，`bootstrap.properties`（或`bootstrap.yml`）和`application.properties`（或`application.yml`）是两个不同的配置文件，它们之间有以下区别：

1. **加载顺序：**
   - `bootstrap`配置文件在Spring Boot应用程序启动时最先加载。它用于配置Spring Boot的应用上下文之前的一些基础设置，通常包括与配置中心的连接和一些系统属性的设置。
   - `application`配置文件是主要的应用程序配置文件，用于配置应用程序的各个组件，例如数据库连接、日志级别、Web服务器端口等。它在`bootstrap`配置文件加载后加载，但在应用程序上下文创建之前。

2. **用途：**
   - `bootstrap`配置文件通常用于配置与应用程序启动相关的基础设置，例如配置中心的连接信息、加密算法、自定义属性解析等。它们在应用程序上下文创建之前加载，因此可以用于配置Spring Cloud Config Server、Nacos等配置中心的连接参数。
   - `application`配置文件用于配置应用程序的具体功能和组件。它包含了应用程序的业务逻辑所需的配置信息，例如数据库连接信息、缓存配置、日志设置等。

3. **覆盖关系：**
   - `bootstrap`配置文件中的属性可以覆盖`application`配置文件中的同名属性。这意味着如果在`bootstrap`配置文件和`application`配置文件中都定义了相同的属性，那么`bootstrap`配置文件中的属性将具有更高的优先级。
   - 通常，`bootstrap`配置文件用于配置一些全局的、与环境无关的基础设置，而`application`配置文件用于配置应用程序的具体行为。

4. **使用场景：**
   - `bootstrap`配置文件适用于配置与应用程序启动相关的内容，以及在应用程序上下文之前需要解析的配置。
   - `application`配置文件适用于配置应用程序的具体功能和组件，包括数据库、消息队列、Web服务器等。

总之，`bootstrap`配置文件和`application`配置文件在Spring Boot应用程序中具有不同的加载顺序和用途。了解它们之间的区别有助于您更好地组织和管理应用程序的配置。

# Nacos集群架构

![img](https://gitlab.com/Echo-xzp/Resource/-/raw/main/img/2023/09/17_10_38_32_af431fa073fd560b873b2d261e9597a1.png)

## 单机模式

- 所有Nacos服务和数据存储在单个节点上运行。
- 适用于开发环境、测试环境或小规模生产环境。
- 优点是部署简单,资源占用少。
- 缺点是可用性较低,无法承担大规模流量,也无法实现高可用。

## 集群模式(无中心化)

- 多个Nacos节点组成一个集群,每个节点都提供完整的服务。
- 节点之间通过Peer-to-Peer的方式进行通信和数据同步。
- 适用于大规模生产环境,可以实现高可用和负载均衡。
- 优点是可扩展性强,容错能力好。
- 缺点是配置相对复杂,需要处理数据一致性问题。

## 集群模式(中心化)

- 多个Nacos节点组成一个集群,其中一个节点为Leader,其他节点为Follower。
- Leader节点负责处理写请求,Follower节点负责处理读请求。
- 适用于对写性能要求较高的场景。
- 优点是读写分离,可以提高写性能。
- 缺点是Leader节点存在单点故障风险,需要引入备用Leader机制。

## 多数据中心模式

- 多个数据中心,每个数据中心部署一个Nacos集群。
- 不同数据中心的Nacos集群之间通过同步机制实现数据的跨中心同步。
- 适用于跨地域部署,需要支持多活的场景。
- 优点是可以实现数据的跨地域容灾,提高整体的可用性。
- 缺点是部署和运维复杂度高,网络延迟可能影响数据同步性能。

## 混合模式

- 结合以上多种模式,形成一个混合部署架构。
- 例如,在每个数据中心部署一个集群,集群内部采用无中心化模式,集群之间采用多数据中心模式。
- 适用于大型复杂的分布式系统,需要兼顾不同层面的需求。
- 优点是可以发挥不同模式的优势,实现高可用、高性能、跨地域等多个目标。
- 缺点是部署和运维复杂度非常高,需要有丰富的经验和完善的工具支撑。

## 集群模式的部署

部署Nacos集群模式需要进行一些配置和准备工作。下面我将详细介绍如何部署Nacos的集群模式。

### 准备工作

- 准备至少3台服务器,每台服务器安装Java运行环境(JDK)。
- 在每台服务器上下载Nacos的安装包,并解压到指定目录。
- 确保服务器之间的网络互通,并且防火墙允许Nacos使用的端口(默认为8848)。

### 配置Nacos

- 进入Nacos的conf目录,找到配置文件`cluster.conf`。

- 在cluster.conf文件中,添加所有Nacos节点的IP地址和端口号,每个节点占一行。例如:

  ```
  192.168.1.1:8848
  192.168.1.2:8848
  192.168.1.3:8848
  ```

- 修改application.properties文件,设置Nacos的运行端口和集群配置文件路径。例如:

  ```
  server.port=8848
  nacos.inetutils.ip-address=192.168.1.1
  nacos.member.list=file:conf/cluster.conf
  ```

- 将配置好的`cluster.conf`和`application.properties`文件复制到每个Nacos节点的conf目录下。

### 启动Nacos集群

- 在每个Nacos节点上,进入bin目录,执行以下命令启动Nacos服务:

  ```
  sh startup.sh -m cluster
  ```

- 启动完成后,可以通过访问每个节点的管理界面(默认为`http://ip:8848/nacos`)来验证集群是否正常运行。

### 配置负载均衡

- 在使用Nacos的应用程序中,需要配置Nacos客户端以连接到Nacos集群。

- 在application.properties或application.yml文件中,设置Nacos的服务地址为所有Nacos节点的IP和端口,用逗号分隔。例如:

  ```
  spring.cloud.nacos.discovery.server-addr=192.168.1.1:8848,192.168.1.2:8848,192.168.1.3:8848
  ```

- Nacos客户端会自动对这些节点进行负载均衡,实现高可用和分流。

### 数据持久化(可选)

- 如果需要保证Nacos的数据持久性,可以配置Nacos使用MySQL作为数据存储。

- 在每个Nacos节点的application.properties文件中,设置MySQL的连接信息。例如:

  ```
  spring.datasource.platform=mysql
  db.num=1
  db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true
  db.user=nacos
  db.password=nacos
  ```

- 创建对应的MySQL数据库和表结构,Nacos会自动使用这个数据库来持久化数据。

以上就是部署Nacos集群模式的主要步骤。在实际的生产环境中,还需要考虑更多的因素,如服务器的硬件配置、网络拓扑、安全防护、监控告警等。同时,也要定期进行数据备份、系统升级等运维操作,以保证集群的稳定运行。

在面试中,你可以结合自己的经验,讲述你在部署Nacos集群时遇到的问题和解决方案,以及你是如何保证集群的高可用和数据一致性的。这会展示你在分布式系统运维和管理方面的实践能力。
